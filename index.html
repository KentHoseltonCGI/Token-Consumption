<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Design Tokens - Token Viewer</title>
    <link rel="stylesheet" href="dist/css/tokens.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
            color: var(--nexus-color-content-primary, #17191c);
            padding: 1rem 1rem 0 1rem;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            height: calc(100% - 2rem);
            display: flex;
            flex-direction: column;
        }

        header {
            background: var(--nexus-color-system-white, #ffffff);
            padding: 2rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2.5rem;
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            color: var(--nexus-color-system-primary-600, #172dbd);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--nexus-color-content-secondary, #575d69);
            font-size: 1.1rem;
        }

        .stats {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .stat {
            background: transparent;
            padding: 0.5rem 0;
            border-radius: 0;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--nexus-color-content-secondary, #575d69);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: var(--nexus-typography-font-weight-regular, 400);
        }

        .stat-value {
            font-size: 1rem;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            color: var(--nexus-color-content-secondary, #575d69);
        }

        .section {
            background: var(--nexus-color-system-white, #ffffff);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            min-height: 0;
            flex: 1;
            margin: 0;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            flex-shrink: 0;
        }

        h2 {
            font-size: 1.25rem;
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            color: var(--nexus-color-content-primary, #17191c);
            margin: 0;
        }

        .token-count {
            background: var(--nexus-color-background-surface-tertiary, #d1d7e3);
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
        }

        .filter-bar {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-shrink: 0;
        }

        .token-tree-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }

        .token-tree {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .token-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .token-card {
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            padding: 1rem;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .token-card:hover {
            border-color: var(--nexus-color-system-primary-500, #3660d0);
            box-shadow: 0 2px 8px rgba(23, 45, 189, 0.1);
        }

        .token-name {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.75rem;
            color: var(--nexus-color-content-secondary, #575d69);
            margin-bottom: 0.5rem;
            word-break: break-all;
        }

        .token-value {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.875rem;
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            color: var(--nexus-color-content-primary, #17191c);
            margin-bottom: 0.75rem;
        }

        .color-swatch {
            width: 100%;
            height: 60px;
            border-radius: 6px;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            margin-bottom: 0.5rem;
        }

        .opacity-bar {
            width: 100%;
            height: 40px;
            background: linear-gradient(90deg, 
                var(--nexus-color-system-primary-600, #172dbd) 0%, 
                transparent 100%);
            border-radius: 6px;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            position: relative;
        }

        .opacity-marker {
            position: absolute;
            height: 100%;
            width: 2px;
            background: var(--nexus-color-system-error-600, #f32245);
            top: 0;
        }

        .spacing-box {
            background: var(--nexus-color-system-primary-100, #e0ebff);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: var(--nexus-color-system-primary-700, #17289c);
            font-weight: var(--nexus-typography-font-weight-medium, 500);
        }

        .font-weight-sample {
            font-size: 1.5rem;
            padding: 0.5rem;
            text-align: center;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            border-radius: 6px;
        }

        .filter-bar {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .filter-top-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-chips {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .filter-chip {
            padding: 0.375rem 0.75rem;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            background: transparent;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8125rem;
            transition: all 0.15s ease;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            color: var(--nexus-color-content-secondary, #575d69);
            user-select: none;
        }

        .filter-chip:hover {
            opacity: 0.8;
        }

        .filter-chip:active {
            transform: translateY(0);
        }

        .filter-chip.active {
            border-color: transparent;
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
        }

        .filter-chip[data-category="all"] {
            border-color: var(--nexus-color-content-secondary, #575d69);
            color: var(--nexus-color-content-secondary, #575d69);
        }

        .filter-chip[data-category="all"]:hover {
            background: rgba(87, 93, 105, 0.08);
        }

        .filter-chip[data-category="all"].active {
            background: var(--nexus-color-content-primary, #17191c);
            color: var(--nexus-color-system-white, #ffffff);
        }

        .filter-chip[data-category="color"] {
            border-color: #c8dcff;
            color: #17289c;
        }

        .filter-chip[data-category="color"]:hover {
            background: rgba(23, 40, 156, 0.08);
        }

        .filter-chip[data-category="color"].active {
            background: #17289c;
            color: var(--nexus-color-system-white, #ffffff);
        }

        .filter-chip[data-category="opacity"] {
            border-color: #c4f5e0;
            color: #13ae5c;
        }

        .filter-chip[data-category="opacity"]:hover {
            background: rgba(19, 174, 92, 0.08);
        }

        .filter-chip[data-category="opacity"].active {
            background: #13ae5c;
            color: var(--nexus-color-system-white, #ffffff);
        }

        .filter-chip[data-category="spacing"] {
            border-color: #ffe2c2;
            color: #d78207;
        }

        .filter-chip[data-category="spacing"]:hover {
            background: rgba(215, 130, 7, 0.08);
        }

        .filter-chip[data-category="spacing"].active {
            background: #d78207;
            color: var(--nexus-color-system-white, #ffffff);
        }

        .filter-chip[data-category="sizing"] {
            border-color: #ffd5d3;
            color: #c61735;
        }

        .filter-chip[data-category="sizing"]:hover {
            background: rgba(198, 23, 53, 0.08);
        }

        .filter-chip[data-category="sizing"].active {
            background: #c61735;
            color: var(--nexus-color-system-white, #ffffff);
        }

        .filter-chip[data-category="typography"] {
            border-color: #c8deff;
            color: #05549e;
        }

        .filter-chip[data-category="typography"]:hover {
            background: rgba(5, 84, 158, 0.08);
        }

        .filter-chip[data-category="typography"].active {
            background: #05549e;
            color: var(--nexus-color-system-white, #ffffff);
        }

        .filter-actions {
            display: flex;
            gap: 0.5rem;
        }

        .filter-btn {
            padding: 0.375rem 0.875rem;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            background: var(--nexus-color-system-white, #ffffff);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8125rem;
            transition: all 0.15s ease;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            color: var(--nexus-color-content-secondary, #575d69);
            white-space: nowrap;
        }

        .filter-btn:hover {
            border-color: var(--nexus-color-system-primary-500, #3660d0);
            color: var(--nexus-color-content-primary, #17191c);
        }

        .filter-btn:active {
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
        }

        .search-wrapper {
            position: relative;
            flex: 1;
            min-width: 200px;
        }

        .search-input {
            width: 100%;
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--nexus-color-system-primary-500, #3660d0);
        }

        .search-clear {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--nexus-color-content-tertiary, #8a909e);
            cursor: pointer;
            padding: 0.25rem;
            display: none;
            font-size: 1.125rem;
            line-height: 1;
            transition: color 0.15s ease;
        }

        .search-clear:hover {
            color: var(--nexus-color-content-primary, #17191c);
        }

        .search-clear.visible {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            margin-bottom: 0.5rem;
        }

        .badge-color { background: #e0ebff; color: #17289c; }
        .badge-opacity { background: #e0fff2; color: #13ae5c; }
        .badge-spacing { background: #ffeedb; color: #d78207; }
        .badge-sizing { background: #ffe9e8; color: #c61735; }
        .badge-typography { background: #e0eeff; color: #05549e; }

        /* Tree View Styles */
        .tree-node {
            margin: 0;
            position: relative;
        }

        .tree-header {
            display: flex;
            align-items: center;
            padding: 0.625rem 0.75rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            user-select: none;
            margin: 2px 0;
            position: relative;
        }

        .tree-header:hover {
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
        }

        .tree-header:active {
            background: var(--nexus-color-background-surface-tertiary, #d1d7e3);
        }

        .tree-toggle {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 0.625rem;
            color: var(--nexus-color-content-secondary, #575d69);
            font-size: 0.625rem;
            transition: transform 0.15s ease;
            flex-shrink: 0;
        }

        .tree-toggle.expanded {
            transform: rotate(90deg);
        }

        .tree-label {
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            color: var(--nexus-color-content-primary, #17191c);
            font-size: 0.875rem;
            flex: 1;
            min-width: 0;
        }

        /* Emphasis for specific top-level categories */
        .token-tree > .tree-node[data-key="nexus"] > .tree-header .tree-label,
        .token-tree > .tree-node[data-key="mui"] > .tree-header .tree-label,
        .token-tree > .tree-node[data-key="ios"] > .tree-header .tree-label {
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
        }

        .tree-count {
            margin-left: 0.75rem;
            font-size: 0.6875rem;
            color: var(--nexus-color-content-secondary, #575d69);
            background: var(--nexus-color-background-surface-tertiary, #d1d7e3);
            padding: 0.125rem 0.5rem;
            border-radius: 12px;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            flex-shrink: 0;
        }

        .tree-children {
            display: none;
            list-style: none;
            padding: 0;
            margin: 0;
            padding-left: 1.5rem;
            border-left: 2px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            margin-left: 0.5rem;
            margin-top: 0.25rem;
            margin-bottom: 0.25rem;
            box-sizing: border-box;
        }

        .tree-children.expanded {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        /* Responsive grid: 1 -> 2 -> 3 -> 4 columns */
        @media (max-width: 768px) {
            .tree-children.expanded {
                grid-template-columns: 1fr;
            }
        }

        @media (min-width: 1200px) {
            .tree-children.expanded {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 1600px) {
            .tree-children.expanded {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        /* Branch nodes should span full width in the grid */
        .tree-node:has(.tree-header) {
            grid-column: 1 / -1;
        }

        .token-leaf {
            display: flex;
            flex-direction: column;
            padding: 0;
            margin: 0;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            border-radius: 8px;
            background: var(--nexus-color-system-white, #ffffff);
            transition: all 0.2s ease;
            cursor: pointer;
            overflow: hidden;
            min-width: 0;
        }

        .token-leaf:hover {
            border-color: var(--nexus-color-system-primary-500, #3660d0);
            box-shadow: 0 4px 12px rgba(23, 45, 189, 0.12);
            box-shadow: 0 2px 8px rgba(23, 45, 189, 0.1);
            transform: translateX(2px);
        }

        .token-leaf:active {
            transform: translateX(0);
            box-shadow: 0 1px 4px rgba(23, 45, 189, 0.15);
        }

        .token-leaf-info {
            padding: 0.875rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            flex: 1;
            min-width: 0;
        }

        .token-leaf-name {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.8125rem;
            color: var(--nexus-color-content-primary, #17191c);
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            word-break: break-word;
            order: 1;
        }

        .token-leaf-reference {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.75rem;
            color: var(--nexus-color-system-primary-700, #17289c);
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            word-break: break-word;
            order: 2;
        }

        .token-leaf-value {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.6875rem;
            color: var(--nexus-color-content-tertiary, #8a909e);
            font-weight: var(--nexus-typography-font-weight-regular, 400);
            word-break: break-word;
            order: 3;
        }

        .token-leaf-label {
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--nexus-color-content-tertiary, #8a909e);
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            margin-bottom: 0.125rem;
        }

        .token-leaf-preview {
            width: 100%;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
            border-bottom: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            padding: 1.5rem;
            position: relative;
        }

        .preview-swatch {
            width: 100%;
            height: 80px;
            border-radius: 8px;
            color: var(--nexus-color-content-primary, #17191c);
            position: relative;
        }

        .token-leaf-value[title] {
            cursor: help;
            border-bottom: 1px dotted var(--nexus-color-content-secondary, #575d69);
        }

        /* Tooltip styles */
        .token-leaf-label {
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--nexus-color-content-tertiary, #8a909e);
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            margin-bottom: 0.125rem;
        }

        .token-leaf-preview {
            width: 100%;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
            border-bottom: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            padding: 1.5rem;
            position: relative;
        }

        .preview-swatch {
            width: 100%;
            height: 80px;
            border-radius: 8px;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .preview-opacity {
            width: 100%;
            height: 80px;
            border-radius: 8px;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            position: relative;
            background-image: 
                linear-gradient(45deg, #ffffff 25%, transparent 25%),
                linear-gradient(-45deg, #ffffff 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ffffff 75%),
                linear-gradient(-45deg, transparent 75%, #ffffff 75%);
            background-size: 12px 12px;
            background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
            background-color: #e4e8f2;
        }

        .preview-opacity-overlay {
            position: absolute;
            inset: 0;
            background: var(--nexus-color-system-primary-600, #172dbd);
            border-radius: 7px;
        }

        .preview-spacing {
            width: 100%;
            height: 80px;
            border-radius: 6px;
            border: 2px dashed var(--nexus-color-system-primary-400, #6c90e5);
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .preview-spacing-box {
            background: var(--nexus-color-system-primary-600, #172dbd);
            border-radius: 2px;
        }

        .preview-radius {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-system-primary-600, #172dbd);
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .preview-border-width {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-background-surface-primary, #ffffff);
            border: solid var(--nexus-color-system-primary-600, #172dbd);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .preview-shadow {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-background-surface-primary, #ffffff);
            border-radius: 8px;
            border: 1px solid var(--nexus-color-background-surface-tertiary, #d1d7e3);
        }

        .preview-weight {
            font-size: 2.5rem;
            color: var(--nexus-color-content-primary, #17191c);
            line-height: 1;
        }

        .preview-font-size {
            color: var(--nexus-color-content-primary, #17191c);
            line-height: 1.2;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }

        .preview-font-family {
            font-size: 2rem;
            color: var(--nexus-color-content-primary, #17191c);
            line-height: 1.2;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }

        .preview-typography {
            color: var(--nexus-color-content-primary, #17191c);
            padding: 1rem;
            display: flex;
            align-items: center;
            min-height: 60px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="section">
            <div class="section-header">
                <h2>Nexus Design Tokens</h2>
                <span class="token-count" id="token-count">0 tokens</span>
            </div>
            <div class="filter-bar">
                <div class="filter-top-row">
                    <div class="search-wrapper">
                        <input type="text" class="search-input" id="search" placeholder="Search tokens...">
                        <button class="search-clear" id="search-clear" title="Clear search">×</button>
                    </div>
                    <div class="filter-actions">
                        <button class="filter-btn" id="expand-all">Expand All</button>
                        <button class="filter-btn" id="collapse-all">Collapse All</button>
                    </div>
                </div>
                <div class="filter-chips" id="filter-chips">
                    <button class="filter-chip active" data-category="all">All</button>
                    <button class="filter-chip" data-category="color">Colors</button>
                    <button class="filter-chip" data-category="opacity">Opacity</button>
                    <button class="filter-chip" data-category="spacing">Spacing</button>
                    <button class="filter-chip" data-category="sizing">Sizing</button>
                    <button class="filter-chip" data-category="typography">Typography</button>
                </div>
            </div>
            <div class="token-tree-container">
                <ul class="token-tree" id="token-tree"></ul>
            </div>
        </div>
    </div>

    <script>
        // Parse CSS custom properties and metadata
        let tokens = [];
        let tokenMetadata = {};
        
        // Fetch both CSS and metadata JSON
        Promise.all([
            fetch('dist/css/tokens.css').then(r => {
                if (!r.ok) throw new Error('Failed to load CSS');
                return r.text();
            }),
            fetch('dist/json/tokens-metadata.json').then(r => {
                if (!r.ok) throw new Error('Failed to load metadata');
                return r.json();
            })
        ])
            .then(([css, metadata]) => {
                console.log('Loaded CSS and metadata successfully');
                
                // Parse CSS custom properties with regex
                const tokenRegex = /--([^:]+):\s*([^;]+);/g;
                let match;
                
                while ((match = tokenRegex.exec(css)) !== null) {
                    const tokenName = `--${match[1].trim()}`;
                    const resolvedValue = match[2].trim();
                    
                    tokens.push({
                        name: tokenName,
                        value: resolvedValue
                    });
                }
                
                console.log(`Parsed ${tokens.length} tokens from CSS`);
                
                // Group typography tokens (h1, h2, body-lg, etc.)
                const typographyGroups = {};
                const typographyTokensToRemove = new Set();
                
                tokens.forEach(token => {
                    const name = token.name;
                    // Match text-token patterns like: --nexus-text-token-h1-font-size
                    const match = name.match(/^--nexus-text-token-([a-z0-9-]+)-(font-weight|font-size|line-height|font-family)$/);
                    if (match) {
                        const typeName = match[1]; // e.g., "h1", "body-lg-emphasized"
                        const property = match[2]; // e.g., "font-size"
                        
                        if (!typographyGroups[typeName]) {
                            typographyGroups[typeName] = {
                                name: `--nexus-text-token-${typeName}`,
                                properties: {}
                            };
                        }
                        
                        typographyGroups[typeName].properties[property] = token.value;
                        typographyTokensToRemove.add(name);
                    }
                });
                
                // Remove individual typography property tokens and add grouped ones
                const filteredTokens = tokens.filter(t => !typographyTokensToRemove.has(t.name));
                
                // Add composite typography tokens
                Object.entries(typographyGroups).forEach(([typeName, group]) => {
                    const props = group.properties;
                    // Create a composite value object that we can use for rendering
                    filteredTokens.push({
                        name: group.name,
                        value: JSON.stringify(props), // Store as JSON for now
                        isCompositeTypography: true,
                        typographyProps: props
                    });
                });
                
                tokens.length = 0;
                tokens.push(...filteredTokens);
                
                console.log(`Grouped typography tokens. Now have ${tokens.length} total tokens`);
                
                // Build metadata map for quick lookup
                function buildMetadataMap(obj, map) {
                    try {
                        if (obj && typeof obj === 'object') {
                            if (obj.name && obj.original && obj.original.$value !== undefined) {
                                // Store both original and resolved values
                                map[`--${obj.name}`] = {
                                    original: obj.original.$value,
                                    resolved: obj.value
                                };
                            }
                            // Recurse through nested objects
                            Object.values(obj).forEach(val => {
                                if (typeof val === 'object') {
                                    buildMetadataMap(val, map);
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error building metadata map:', e);
                    }
                }
                buildMetadataMap(metadata, tokenMetadata);
                
                console.log(`Built metadata for ${Object.keys(tokenMetadata).length} tokens`);
                
                // Initialize the UI after tokens are loaded
                initializeUI();
            })
            .catch(error => {
                console.error('Error loading tokens:', error);
                document.getElementById('token-tree').innerHTML = 
                    `<p style="text-align: center; color: #f32245; padding: 2rem;">Error loading tokens: ${error.message}<br>Make sure to run <code>npm run build</code> first and serve this page via a local server.</p>`;
            });
        
        function initializeUI() {
            // Build hierarchical tree structure from flat token list with architectural layers
            function buildTree(tokens) {
                const tree = {};
                
                // Merge compound names before splitting
                function normalizeTokenName(tokenName) {
                    // Remove -- prefix
                    let name = tokenName.replace(/^--/, '');
                    
                    // Compound color names that should be treated as single units
                    const compoundNames = {
                        'deep-blue': 'deepBlue',
                        'deep-green': 'deepGreen',
                        'bright-yellow': 'brightYellow',
                        'on-color': 'onColor',
                        'on-subtle': 'onSubtle',
                        'mid-blue': 'midBlue',
                        'mid-green': 'midGreen',
                        'new-sky': 'newSky',
                        'day-glow': 'dayGlow',
                        'action-lighter': 'actionLighter',
                        'action-light': 'actionLight',
                        'action-dark': 'actionDark',
                        'action-darker': 'actionDarker'
                    };
                    
                    // Replace compound names with single tokens
                    for (const [compound, replacement] of Object.entries(compoundNames)) {
                        name = name.replace(compound, replacement);
                    }
                    
                    return name;
                }
                
                // Layer classification based on actual token architecture
                function categorizeToken(pathParts, topLevel) {
                    const category = pathParts[1]; // e.g., 'color', 'sizing', 'spacing', 'opacity'
                    const subcategory = pathParts[2]; // e.g., 'neutral', 'system', 'content', 'background'
                    
                    // Layer 01 - Primitives: Raw color ramps (neutral, slate, red, etc.) and base scales
                    const primitiveColorRamps = ['neutral', 'slate', 'deepBlue', 'blue', 'teal', 'green', 
                                                  'lime', 'brightYellow', 'orange', 'red', 'pink', 'purple', 
                                                  'violet', 'deepGreen', 'amber', 'yellow'];
                    
                    if (category === 'color' && primitiveColorRamps.includes(subcategory)) {
                        // Layer 01: Raw color ramps - flatten the structure
                        return ['primitives', 'color-ramps', subcategory, ...pathParts.slice(3)];
                    } else if (category === 'sizing' || category === 'spacing') {
                        // Layer 01: Base scales (rem-based) - flatten numeric values
                        return ['primitives', 'scales', category, ...pathParts.slice(2)];
                    } else if (category === 'opacity') {
                        // Layer 03: Opacity tokens - flatten completely, no subfolders
                        return ['component-ui', 'opacity', pathParts.slice(2).join('-')];
                    } else if (category === 'gradient') {
                        // Layer 03: Gradient tokens - UI-level tokens
                        return ['component-ui', 'gradient', ...pathParts.slice(2)];
                    } else if (category === 'color' && subcategory === 'brand') {
                        // Layer 02: Brand colors belong in semantic system
                        return ['semantic-system', 'brand', ...pathParts.slice(3)];
                    } else if (category === 'color' && subcategory === 'system') {
                        // Check if it's system.content which is actually Layer 03
                        const thirdLevel = pathParts[3];
                        if (thirdLevel === 'content') {
                            // Layer 03: system.content is UI-level
                            return ['component-ui', 'color', 'system-content', ...pathParts.slice(4)];
                        }
                        // Layer 02: Semantic system colors (system.error, system.success, etc.)
                        return ['semantic-system', 'color', ...pathParts.slice(3)];
                    } else if (category === 'color' && (subcategory === 'content' || subcategory === 'background' || subcategory === 'border' || subcategory === 'foreground')) {
                        // Layer 03: UI/Component tokens - keep structure but flatten where needed
                        return ['component-ui', 'color', subcategory, ...pathParts.slice(3)];
                    } else if (category === 'opacity' || category === 'shape') {
                        // Layer 03: UI properties
                        return ['component-ui', category, ...pathParts.slice(2)];
                    } else if (category === 'text' || category === 'typography' || category === 'surface' || category === 'effect') {
                        // Layer 03: Component-specific tokens
                        return ['component-ui', category, ...pathParts.slice(2)];
                    } else {
                        // Default: keep original structure
                        return pathParts.slice(1);
                    }
                }
                
                tokens.forEach(token => {
                    // Normalize compound names first
                    const normalizedName = normalizeTokenName(token.name);
                    
                    // Split by hyphen to get path parts
                    let path = normalizedName.split('-');
                    const topLevel = path[0].toLowerCase();
                    
                    // Handle mui and ios as separate top-level categories (no layer restructuring)
                    if (topLevel === 'mui' || topLevel === 'ios') {
                        // Keep mui/ios as-is
                    } else if (topLevel === 'nexus') {
                        // Apply layer categorization to nexus tokens
                        const layeredPath = categorizeToken(path, topLevel);
                        path = ['nexus', ...layeredPath];
                    } else {
                        // All other tokens go under nexus with layer categorization
                        path = ['nexus', ...categorizeToken(['nexus', path[0], ...path.slice(1)], 'nexus')];
                    }
                    
                    let current = tree;
                    
                    // Navigate/create tree structure
                    for (let i = 0; i < path.length; i++) {
                        const part = path[i];
                        
                        if (i === path.length - 1) {
                            // Leaf node - store token data
                            if (!current._tokens) current._tokens = [];
                            current._tokens.push({
                                name: token.name,
                                value: token.value,
                                path: path
                            });
                        } else {
                            // Branch node
                            if (!current[part]) {
                                current[part] = {};
                            }
                            current = current[part];
                        }
                    }
                });
                
                return tree;
            }
            
            // Collapse folders that only contain a single child folder (no tokens)
            function collapseSingleChildFolders(node) {
                // Get all keys except _tokens
                const keys = Object.keys(node).filter(k => k !== '_tokens');
                
                // If this node has exactly one child and no tokens of its own
                if (keys.length === 1 && (!node._tokens || node._tokens.length === 0)) {
                    const childKey = keys[0];
                    const child = node[childKey];
                    
                    // Recursively collapse the child first
                    collapseSingleChildFolders(child);
                    
                    // Merge the child's contents into this node
                    Object.keys(child).forEach(key => {
                        node[key] = child[key];
                    });
                    
                    // Remove the now-redundant child folder
                    delete node[childKey];
                } else {
                    // Recursively process all children
                    keys.forEach(key => {
                        if (typeof node[key] === 'object') {
                            collapseSingleChildFolders(node[key]);
                        }
                    });
                }
                
                return node;
            }
            
            // Get token category for visual preview
            function getTokenCategory(name) {
                if (name.includes('-color-')) return 'color';
                if (name.includes('-opacity-')) return 'opacity';
                if (name.includes('-spacing-')) return 'spacing';
                if (name.includes('-sizing-')) return 'sizing';
                if (name.includes('-font-weight-')) return 'font-weight';
                if (name.includes('-font-size-')) return 'font-size';
                if (name.includes('-font-family-')) return 'font-family';
                if (name.includes('-typography-') || name.includes('-text-token-')) return 'typography';
                if (name.includes('-shape-') || name.includes('-radius-') || name.includes('-border-radius-')) return 'border-radius';
                if (name.includes('-border-width-')) return 'border-width';
                if (name.includes('-shadow-') || name.includes('-effect-')) return 'shadow';
                return 'other';
            }
            
            // Render preview based on token category
            function renderPreview(token) {
                // Check if this is a composite typography token
                if (token.isCompositeTypography && token.typographyProps) {
                    const props = token.typographyProps;
                    const styles = [];
                    
                    if (props['font-family']) styles.push(`font-family: ${props['font-family']}`);
                    if (props['font-size']) styles.push(`font-size: ${props['font-size']}`);
                    if (props['font-weight']) styles.push(`font-weight: ${props['font-weight']}`);
                    if (props['line-height']) styles.push(`line-height: ${props['line-height']}`);
                    
                    const styleStr = styles.join('; ');
                    const displayText = token.name.includes('-h1') ? 'Heading 1' :
                                       token.name.includes('-h2') ? 'Heading 2' :
                                       token.name.includes('-h3') ? 'Heading 3' :
                                       token.name.includes('-h4') ? 'Heading 4' :
                                       token.name.includes('-h5') ? 'Heading 5' :
                                       token.name.includes('-h6') ? 'Heading 6' :
                                       token.name.includes('-subtitle') ? 'Subtitle text' :
                                       token.name.includes('-button') ? 'Button text' :
                                       token.name.includes('-caption') ? 'Caption text' :
                                       token.name.includes('-label') ? 'Label text' :
                                       token.name.includes('-link') ? 'Link text' :
                                       'Body text sample';
                    
                    const previewContent = `<div class="preview-typography" style="${styleStr}">${displayText}</div>`;
                    return `<div class="token-leaf-preview">${previewContent}</div>`;
                }
                
                const category = getTokenCategory(token.name);
                let previewContent = '';
                
                switch (category) {
                    case 'color':
                        previewContent = `<div class="preview-swatch" style="background-color: ${token.value};"></div>`;
                        break;
                    
                    case 'opacity':
                        previewContent = `<div class="preview-opacity"><div class="preview-opacity-overlay" style="opacity: ${token.value};"></div></div>`;
                        break;
                    
                    case 'spacing':
                    case 'sizing':
                        // Show a box with the actual dimension
                        const size = token.value;
                        previewContent = `<div class="preview-spacing"><div class="preview-spacing-box" style="width: ${size}; height: ${size};"></div></div>`;
                        break;
                    
                    case 'border-radius':
                        previewContent = `<div class="preview-radius" style="border-radius: ${token.value};"></div>`;
                        break;
                    
                    case 'border-width':
                        previewContent = `<div class="preview-border-width" style="border-width: ${token.value};"></div>`;
                        break;
                    
                    case 'font-weight':
                        previewContent = `<div class="preview-weight" style="font-weight: ${token.value};">Ag</div>`;
                        break;
                    
                    case 'font-size':
                        previewContent = `<div class="preview-font-size" style="font-size: ${token.value};">Ag</div>`;
                        break;
                    
                    case 'font-family':
                        previewContent = `<div class="preview-font-family" style="font-family: ${token.value};">Ag</div>`;
                        break;
                    
                    case 'typography':
                        // For composite typography tokens, show text with combined styles
                        previewContent = `<div class="preview-typography" style="font: ${token.value};">The quick brown fox</div>`;
                        break;
                    
                    case 'shadow':
                        previewContent = `<div class="preview-shadow" style="box-shadow: ${token.value};"></div>`;
                        break;
                    
                    default:
                        previewContent = `<div style="font-size: 0.75rem; color: var(--nexus-color-content-tertiary, #8a909e);">No preview</div>`;
                }
                
                return `<div class="token-leaf-preview">${previewContent}</div>`;
            }
            
            // Render tree node recursively
            function renderTreeNode(key, node, depth = 0) {
                const li = document.createElement('li');
                li.className = 'tree-node';
                li.setAttribute('data-key', key.toLowerCase());
                
                // Check if this node has children or tokens
                const hasChildren = Object.keys(node).some(k => k !== '_tokens');
                const hasTokens = node._tokens && node._tokens.length > 0;
                
                if (hasChildren || hasTokens) {
                    const header = document.createElement('div');
                    header.className = 'tree-header';
                    
                    const toggle = document.createElement('span');
                    toggle.className = 'tree-toggle';
                    toggle.textContent = '▶';
                    
                    const label = document.createElement('span');
                    label.className = 'tree-label';
                    
                    // Friendly names for architectural layers
                    const layerNames = {
                        'primitives': 'Primitives',
                        'color-ramps': 'Color Ramps',
                        'scales': 'Base Scales',
                        'semantic-system': 'Alias',
                        'component-ui': 'Mapped'
                    };
                    
                    label.textContent = layerNames[key.toLowerCase()] || key;
                    
                    const count = document.createElement('span');
                    count.className = 'tree-count';
                    const totalCount = countTokens(node);
                    count.textContent = `${totalCount}`;
                    
                    header.appendChild(toggle);
                    header.appendChild(label);
                    header.appendChild(count);
                    
                    const childrenUl = document.createElement('ul');
                    childrenUl.className = 'tree-children';
                    
                    // Custom sort order for architectural layers within nexus
                    const layerSortOrder = ['primitives', 'semantic-system', 'component-ui'];
                    const childKeys = Object.keys(node).filter(k => k !== '_tokens');
                    
                    const sortedChildKeys = childKeys.sort((a, b) => {
                        const aLower = a.toLowerCase();
                        const bLower = b.toLowerCase();
                        const aIndex = layerSortOrder.indexOf(aLower);
                        const bIndex = layerSortOrder.indexOf(bLower);
                        
                        // If both are layers, sort by their position
                        if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                        // If only a is a layer, it comes first
                        if (aIndex !== -1) return -1;
                        // If only b is a layer, it comes first
                        if (bIndex !== -1) return 1;
                        // Otherwise, alphabetical sort
                        return aLower.localeCompare(bLower);
                    });
                    
                    // Render child branches
                    sortedChildKeys.forEach(childKey => {
                        childrenUl.appendChild(renderTreeNode(childKey, node[childKey], depth + 1));
                    });
                    
                    // Render leaf tokens
                    if (hasTokens) {
                        node._tokens.forEach(token => {
                            const tokenLi = document.createElement('li');
                            tokenLi.className = 'tree-node';
                            
                            // Check if we have metadata for this token
                            const metadata = tokenMetadata[token.name];
                            const originalValue = metadata?.original || token.value;
                            let resolvedValue = token.value;
                            
                            // Special handling for composite typography tokens
                            if (token.isCompositeTypography && token.typographyProps) {
                                const props = token.typographyProps;
                                const parts = [];
                                if (props['font-family']) parts.push(`family: ${props['font-family']}`);
                                if (props['font-size']) parts.push(`size: ${props['font-size']}`);
                                if (props['font-weight']) parts.push(`weight: ${props['font-weight']}`);
                                if (props['line-height']) parts.push(`line-height: ${props['line-height']}`);
                                resolvedValue = parts.join(' • ');
                            }
                            
                            // Check if this token references another token
                            const isReference = String(originalValue).includes('{') && String(originalValue).includes('}');
                            
                            // Build the card: 1) VISUAL PREVIEW (hero), 2) TOKEN NAME, 3) REFERENCE (if exists), 4) RESOLVED VALUE
                            let infoHTML = '';
                            
                            if (isReference) {
                                // Show token name, then reference, then resolved value
                                infoHTML = `
                                    <div class="token-leaf-name">${token.name}</div>
                                    <div class="token-leaf-reference">${originalValue}</div>
                                    <div class="token-leaf-value">→ ${resolvedValue}</div>
                                `;
                            } else {
                                // Show token name, then value directly
                                infoHTML = `
                                    <div class="token-leaf-name">${token.name}</div>
                                    <div class="token-leaf-value">${resolvedValue}</div>
                                `;
                            }
                            
                            tokenLi.innerHTML = `
                                <div class="token-leaf">
                                    ${renderPreview(token)}
                                    <div class="token-leaf-info">
                                        ${infoHTML}
                                    </div>
                                </div>
                            `;
                            childrenUl.appendChild(tokenLi);
                        });
                    }
                    
                    // Toggle expand/collapse
                    header.addEventListener('click', () => {
                        const isExpanded = childrenUl.classList.contains('expanded');
                        if (isExpanded) {
                            childrenUl.classList.remove('expanded');
                            toggle.classList.remove('expanded');
                        } else {
                            childrenUl.classList.add('expanded');
                            toggle.classList.add('expanded');
                        }
                    });
                    
                    li.appendChild(header);
                    li.appendChild(childrenUl);
                }
                
                return li;
            }
            
            // Count total tokens in a branch
            function countTokens(node) {
                let count = 0;
                if (node._tokens) count += node._tokens.length;
                Object.keys(node).forEach(key => {
                    if (key !== '_tokens') {
                        count += countTokens(node[key]);
                    }
                });
                return count;
            }
            
            // Build and render the tree
            const tree = buildTree(tokens);
            
            // Collapse any folders that only contain a single child folder
            Object.keys(tree).forEach(key => {
                collapseSingleChildFolders(tree[key]);
            });
            
            const treeContainer = document.getElementById('token-tree');
            
            // Custom sort order for top-level categories
            const sortOrder = ['nexus', 'mui', 'ios'];
            const sortedKeys = Object.keys(tree).sort((a, b) => {
                const aLower = a.toLowerCase();
                const bLower = b.toLowerCase();
                const aIndex = sortOrder.indexOf(aLower);
                const bIndex = sortOrder.indexOf(bLower);
                
                // If both are in the priority list, sort by their position
                if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                // If only a is in the list, it comes first
                if (aIndex !== -1) return -1;
                // If only b is in the list, it comes first
                if (bIndex !== -1) return 1;
                // Otherwise, alphabetical sort
                return aLower.localeCompare(bLower);
            });
            
            sortedKeys.forEach(key => {
                treeContainer.appendChild(renderTreeNode(key, tree[key]));
            });
            
            // Update token count
            document.getElementById('token-count').textContent = `${tokens.length} tokens`;
            
            // Expand/Collapse All functionality
            document.getElementById('expand-all').addEventListener('click', () => {
                document.querySelectorAll('.tree-children').forEach(el => {
                    el.classList.add('expanded');
                });
                document.querySelectorAll('.tree-toggle').forEach(el => {
                    el.classList.add('expanded');
                });
            });
            
            document.getElementById('collapse-all').addEventListener('click', () => {
                document.querySelectorAll('.tree-children').forEach(el => {
                    el.classList.remove('expanded');
                });
                document.querySelectorAll('.tree-toggle').forEach(el => {
                    el.classList.remove('expanded');
                });
            });
            
            // Filter chip functionality
            let activeCategory = 'all';
            const filterChips = document.querySelectorAll('.filter-chip');
            
            filterChips.forEach(chip => {
                chip.addEventListener('click', () => {
                    // Update active state
                    filterChips.forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    
                    // Get selected category
                    activeCategory = chip.dataset.category;
                    
                    // Apply filter
                    applyFilters();
                });
            });
            
            // Search functionality
            const searchInput = document.getElementById('search');
            const searchClear = document.getElementById('search-clear');
            
            searchInput.addEventListener('input', () => {
                // Show/hide clear button based on input
                if (searchInput.value) {
                    searchClear.classList.add('visible');
                } else {
                    searchClear.classList.remove('visible');
                }
                applyFilters();
            });
            
            searchClear.addEventListener('click', () => {
                searchInput.value = '';
                searchClear.classList.remove('visible');
                applyFilters();
                searchInput.focus();
            });
            
            // Combined filter function
            function applyFilters() {
                const searchTerm = searchInput.value.toLowerCase();
                const leaves = document.querySelectorAll('.token-leaf');
                
                // First pass: Show/hide token leaves based on filters
                leaves.forEach(leaf => {
                    const name = leaf.querySelector('.token-leaf-name').textContent.toLowerCase();
                    const category = getTokenCategory(name);
                    
                    const matchesSearch = name.includes(searchTerm) || searchTerm === '';
                    const matchesCategory = activeCategory === 'all' || category === activeCategory;
                    
                    leaf.parentElement.style.display = matchesSearch && matchesCategory ? 'block' : 'none';
                });
                
                // Second pass: Show/hide tree branches based on visible children
                // Process from bottom up to ensure parent visibility is correct
                const allTreeNodes = Array.from(document.querySelectorAll('.tree-node')).reverse();
                
                allTreeNodes.forEach(node => {
                    const childrenContainer = node.querySelector(':scope > .tree-children');
                    
                    if (childrenContainer) {
                        // Check if this branch has any visible descendants
                        const hasVisibleDescendants = Array.from(childrenContainer.querySelectorAll('.token-leaf')).some(
                            leaf => leaf.parentElement.style.display !== 'none'
                        ) || Array.from(childrenContainer.querySelectorAll(':scope > .tree-node')).some(
                            childNode => childNode.style.display !== 'none'
                        );
                        
                        if (hasVisibleDescendants) {
                            node.style.display = 'block';
                            // Auto-expand parent trees that have matching results
                            if (searchTerm) {
                                childrenContainer.classList.add('expanded');
                            }
                        } else {
                            node.style.display = 'none';
                        }
                    } else {
                        // Leaf node (contains token-leaf), already handled in first pass
                    }
                });
                
                // If no filters active, show everything and collapse all
                if (!searchTerm && activeCategory === 'all') {
                    document.querySelectorAll('.tree-node').forEach(node => {
                        node.style.display = 'block';
                    });
                    // Collapse all when clearing search
                    document.querySelectorAll('.tree-children').forEach(container => {
                        container.classList.remove('expanded');
                    });
                }
            }
        }
    </script>
</body>
</html>
