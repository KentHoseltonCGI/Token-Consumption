<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Design Tokens - Token Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="dist/css/tokens.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--nexus-typography-font-family-inter, Inter), -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: var(--nexus-text-token-body-md-default-font-size, 0.875rem);
            font-weight: var(--nexus-typography-font-weight-regular, 400);
            line-height: var(--nexus-text-token-body-md-default-line-height, 1.6);
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
            color: var(--nexus-color-content-primary, #17191c);
            padding: var(--nexus-spacing-4, 1rem) var(--nexus-spacing-4, 1rem) 0 var(--nexus-spacing-4, 1rem);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            height: calc(100% - var(--nexus-spacing-8, 2rem));
            display: flex;
            flex-direction: column;
        }

        header {
            background: var(--nexus-color-background-surface-primary, #ffffff);
            padding: var(--nexus-spacing-8, 2rem);
            border-radius: var(--nexus-shape-border-radius-sm, 16px);
            margin-bottom: var(--nexus-spacing-8, 2rem);
            box-shadow: var(--nexus-effect-bottom-shadow-sm, 0 1px 4px 0 rgba(0,0,0,0.12));
        }

        h1 {
            font: var(--nexus-headings-h2, 600 28px/1.2 Inter);
            color: var(--nexus-color-content-link, #172dbd);
            margin-bottom: var(--nexus-spacing-2, 0.5rem);
        }

        .subtitle {
            font: var(--nexus-body-lg-subtle, 300 16px/1.6 Inter);
            color: var(--nexus-color-content-secondary, #575d69);
        }

        .stats {
            display: flex;
            gap: var(--nexus-spacing-6, 1.5rem);
            margin-top: var(--nexus-spacing-4, 1rem);
            flex-wrap: wrap;
        }

        .stat {
            background: transparent;
            padding: 0.5rem 0;
            border-radius: 0;
        }

        .stat-label {
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            color: var(--nexus-color-content-secondary, #575d69);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-value {
            font-size: var(--nexus-text-token-body-md-default-font-size, 0.875rem);
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            line-height: var(--nexus-text-token-body-md-default-line-height, 1.6);
            color: var(--nexus-color-content-secondary, #575d69);
        }

        .section {
            background: var(--nexus-color-background-surface-primary, #ffffff);
            padding: var(--nexus-spacing-8, 2rem);
            border-radius: var(--nexus-shape-border-radius-sm, 16px);
            box-shadow: var(--nexus-effect-bottom-shadow-sm, 0 1px 4px 0 rgba(0,0,0,0.12));
            display: flex;
            flex-direction: column;
            min-height: 0;
            flex: 1;
            margin: 0;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--nexus-spacing-3, 0.75rem);
            padding-bottom: var(--nexus-spacing-2, 0.5rem);
            border-bottom: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            flex-shrink: 0;
        }

        h2 {
            font: var(--nexus-headings-h6, 600 16px/1.2 Inter);
            color: var(--nexus-color-content-primary, #17191c);
            margin: 0;
        }

        .token-count {
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            background: var(--nexus-color-background-surface-tertiary, #d1d7e3);
            padding: var(--nexus-spacing-1, 0.25rem) var(--nexus-sizing-62, 0.625rem);
            border-radius: var(--nexus-shape-border-radius-round, 320px);
        }

        .filter-bar {
            display: flex;
            flex-direction: column;
            gap: var(--nexus-spacing-3, 0.75rem);
            margin-bottom: var(--nexus-spacing-6, 1.5rem);
            flex-shrink: 0;
        }

        .token-tree-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }

        .token-tree {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .token-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--nexus-spacing-4, 1rem);
        }

        .token-card {
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            padding: var(--nexus-spacing-4, 1rem);
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            transition: all 0.2s;
        }

        .token-card:hover {
            border-color: var(--nexus-color-border-focused, #3660d0);
            box-shadow: var(--nexus-effect-bottom-shadow-md, 0 2px 8px 0 rgba(0,0,0,0.12));
        }

        .token-name {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-caption-sm-font-size, 0.75rem);
            color: var(--nexus-color-content-secondary, #575d69);
            margin-bottom: var(--nexus-spacing-2, 0.5rem);
            word-break: break-all;
        }

        .token-value {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-body-md-default-font-size, 0.875rem);
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            color: var(--nexus-color-content-primary, #17191c);
            margin-bottom: var(--nexus-spacing-3, 0.75rem);
        }

        .color-swatch {
            width: 100%;
            height: 60px;
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            margin-bottom: var(--nexus-spacing-2, 0.5rem);
        }

        .opacity-bar {
            width: 100%;
            height: 40px;
            background: linear-gradient(90deg, 
                var(--nexus-color-content-link, #172dbd) 0%, 
                transparent 100%);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            position: relative;
        }

        .opacity-marker {
            position: absolute;
            height: 100%;
            width: var(--nexus-shape-border-width-emphasized, 2px);
            background: var(--nexus-color-system-error-600, #f32245);
            top: 0;
        }

        .spacing-box {
            background: var(--nexus-color-background-primary-subtle, #e0ebff);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            display: flex;
            align-items: center;
            justify-content: center;
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            color: var(--nexus-color-foreground-primary-on-subtle, #17289c);
        }

        .font-weight-sample {
            font-size: var(--nexus-text-token-h5-font-size, 1.5rem);
            padding: var(--nexus-spacing-2, 0.5rem);
            text-align: center;
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
        }

        .filter-bar {
            display: flex;
            flex-direction: column;
            gap: var(--nexus-spacing-3, 0.75rem);
            margin-bottom: var(--nexus-spacing-6, 1.5rem);
        }

        .filter-top-row {
            display: flex;
            gap: var(--nexus-spacing-3, 0.75rem);
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-chips {
            display: flex;
            gap: var(--nexus-spacing-2, 0.5rem);
            flex-wrap: wrap;
        }

        .filter-chip {
            padding: var(--nexus-spacing-1, 0.25rem) var(--nexus-spacing-3, 0.75rem);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            background: transparent;
            border-radius: var(--nexus-shape-border-radius-md, 20px);
            cursor: pointer;
            font: var(--nexus-label-md, 500 14px/1 Inter);
            transition: all 0.15s ease;
            color: var(--nexus-color-content-secondary, #575d69);
            user-select: none;
        }

        .filter-chip:hover {
            opacity: 0.8;
        }

        .filter-chip:active {
            transform: translateY(0);
        }

        .filter-chip.active {
            border-color: transparent;
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
        }

        .filter-chip[data-category="all"] {
            border-color: var(--nexus-color-content-secondary, #575d69);
            color: var(--nexus-color-content-secondary, #575d69);
        }

        .filter-chip[data-category="all"]:hover {
            background: var(--nexus-color-background-surface-disabled-bg, rgba(23, 25, 28, 0.12));
        }

        .filter-chip[data-category="all"].active {
            background: var(--nexus-color-content-primary, #17191c);
            color: var(--nexus-color-foreground-primary-on-color, #ffffff);
        }

        .filter-chip[data-category="color"] {
            border-color: var(--nexus-color-deep-blue-200, #c2d5fc);
            color: var(--nexus-color-deep-blue-700, #17289c);
        }

        .filter-chip[data-category="color"]:hover {
            background: var(--nexus-color-background-info-subtle, #e0ebff);
        }

        .filter-chip[data-category="color"].active {
            background: var(--nexus-color-deep-blue-700, #17289c);
            color: var(--nexus-color-foreground-primary-on-color, #ffffff);
        }

        .filter-chip[data-category="opacity"] {
            border-color: var(--nexus-color-deep-green-200, #cef5d6);
            color: var(--nexus-color-deep-green-600, #13ae5c);
        }

        .filter-chip[data-category="opacity"]:hover {
            background: var(--nexus-color-background-success-subtle, #e1fae7);
        }

        .filter-chip[data-category="opacity"].active {
            background: var(--nexus-color-deep-green-600, #13ae5c);
            color: var(--nexus-color-foreground-success-on-color, #ffffff);
        }

        .filter-chip[data-category="spacing"] {
            border-color: var(--nexus-color-yellow-200, #ffe0ba);
            color: var(--nexus-color-yellow-700, #d78207);
        }

        .filter-chip[data-category="spacing"]:hover {
            background: var(--nexus-color-background-warning-subtle, #ffeedb);
        }

        .filter-chip[data-category="spacing"].active {
            background: var(--nexus-color-yellow-700, #d78207);
            color: var(--nexus-color-foreground-warning-on-color, #17191c);
        }

        .filter-chip[data-category="sizing"] {
            border-color: var(--nexus-color-red-200, #ffcbc9);
            color: var(--nexus-color-red-700, #c61735);
        }

        .filter-chip[data-category="sizing"]:hover {
            background: var(--nexus-color-background-error-subtle, #ffe9e8);
        }

        .filter-chip[data-category="sizing"].active {
            background: var(--nexus-color-red-700, #c61735);
            color: var(--nexus-color-foreground-error-on-color, #ffffff);
        }

        .filter-chip[data-category="typography"] {
            border-color: var(--nexus-color-blue-200, #cae0fc);
            color: var(--nexus-color-blue-700, #05549e);
        }

        .filter-chip[data-category="typography"]:hover {
            background: var(--nexus-color-background-secondary-subtle, #e0eeff);
        }

        .filter-chip[data-category="typography"].active {
            background: var(--nexus-color-blue-700, #05549e);
            color: var(--nexus-color-foreground-accent-on-color, #ffffff);
        }

        .filter-chip[data-category="gradient"] {
            border-color: var(--nexus-color-teal-200, #c2efff);
            color: var(--nexus-color-teal-600, #029bd1);
        }

        .filter-chip[data-category="gradient"]:hover {
            background: var(--nexus-color-teal-100, #def7ff);
        }

        .filter-chip[data-category="gradient"].active {
            background: var(--nexus-color-teal-600, #029bd1);
            color: var(--nexus-color-foreground-accent-on-color, #ffffff);
        }

        .filter-chip[data-category="effect"] {
            border-color: var(--nexus-color-deep-blue-300, #a6c0f7);
            color: var(--nexus-color-deep-blue-800, #15227a);
        }

        .filter-chip[data-category="effect"]:hover {
            background: var(--nexus-color-background-primary-subtle, #e0ebff);
        }

        .filter-chip[data-category="effect"].active {
            background: var(--nexus-color-deep-blue-800, #15227a);
            color: var(--nexus-color-foreground-primary-on-color, #ffffff);
        }

        .filter-actions {
            display: flex;
            gap: var(--nexus-spacing-2, 0.5rem);
        }

        .filter-btn {
            padding: var(--nexus-spacing-1, 0.25rem) var(--nexus-sizing-88, 0.875rem);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            background: var(--nexus-color-background-surface-primary, #ffffff);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            cursor: pointer;
            font: var(--nexus-label-md, 500 14px/1 Inter);
            transition: all 0.15s ease;
            color: var(--nexus-color-content-secondary, #575d69);
            white-space: nowrap;
        }

        .filter-btn:hover {
            border-color: var(--nexus-color-border-focused, #3660d0);
            color: var(--nexus-color-content-primary, #17191c);
        }

        .filter-btn:active {
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
        }

        .search-wrapper {
            position: relative;
            flex: 1;
            min-width: 200px;
        }

        .search-input {
            width: 100%;
            padding: var(--nexus-spacing-2, 0.5rem) 2.5rem var(--nexus-spacing-2, 0.5rem) var(--nexus-spacing-4, 1rem);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            font: var(--nexus-body-md-default, 400 14px/1.6 Inter);
            color: var(--nexus-color-content-primary, #17191c);
            background: var(--nexus-color-background-surface-primary, #ffffff);
        }

        .search-input::placeholder {
            color: var(--nexus-color-content-tertiary, #8a909e);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--nexus-color-border-focused, #3660d0);
        }

        .search-clear {
            position: absolute;
            right: var(--nexus-spacing-2, 0.5rem);
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--nexus-color-content-tertiary, #8a909e);
            cursor: pointer;
            padding: var(--nexus-spacing-1, 0.25rem);
            display: none;
            font-size: var(--nexus-text-token-body-lg-default-font-size, 1rem);
            line-height: 1;
            transition: color 0.15s ease;
        }

        .search-clear:hover {
            color: var(--nexus-color-content-primary, #17191c);
        }

        .search-clear.visible {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: var(--nexus-spacing-1, 0.125rem) var(--nexus-spacing-2, 0.5rem);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            margin-bottom: var(--nexus-spacing-2, 0.5rem);
        }

        .badge-color { background: var(--nexus-color-background-primary-subtle, #e0ebff); color: var(--nexus-color-deep-blue-700, #17289c); }
        .badge-opacity { background: var(--nexus-color-background-success-subtle, #e1fae7); color: var(--nexus-color-deep-green-600, #13ae5c); }
        .badge-spacing { background: var(--nexus-color-background-warning-subtle, #ffeedb); color: var(--nexus-color-yellow-700, #d78207); }
        .badge-sizing { background: var(--nexus-color-background-error-subtle, #ffe9e8); color: var(--nexus-color-red-700, #c61735); }
        .badge-typography { background: var(--nexus-color-background-secondary-subtle, #e0eeff); color: var(--nexus-color-blue-700, #05549e); }
        .badge-effect { background: var(--nexus-color-background-primary-subtle, #e0ebff); color: var(--nexus-color-deep-blue-800, #15227a); }
        .badge-gradient { background: var(--nexus-color-teal-100, #def7ff); color: var(--nexus-color-teal-600, #029bd1); }

        /* Tree View Styles */
        .tree-node {
            margin: 0;
            position: relative;
        }

        .tree-header {
            display: flex;
            align-items: center;
            padding: var(--nexus-sizing-62, 0.625rem) var(--nexus-spacing-3, 0.75rem);
            cursor: pointer;
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            transition: all 0.2s ease;
            user-select: none;
            margin: var(--nexus-shape-border-width-emphasized, 2px) 0;
            position: relative;
        }

        .tree-header:hover {
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
        }

        .tree-header:active {
            background: var(--nexus-color-background-surface-tertiary, #d1d7e3);
        }

        .tree-toggle {
            width: var(--nexus-sizing-112, 1.125rem);
            height: var(--nexus-sizing-112, 1.125rem);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 0.625rem;
            color: var(--nexus-color-content-secondary, #575d69);
            font-size: 0.625rem;
            transition: transform 0.15s ease;
            flex-shrink: 0;
        }

        .tree-toggle.expanded {
            transform: rotate(90deg);
        }

        .tree-label {
            font: var(--nexus-label-md, 500 14px/1 Inter);
            color: var(--nexus-color-content-primary, #17191c);
            flex: 1;
            min-width: 0;
        }

        /* Emphasis for specific top-level categories */
        .token-tree > .tree-node[data-key="nexus"] > .tree-header .tree-label,
        .token-tree > .tree-node[data-key="mui"] > .tree-header .tree-label,
        .token-tree > .tree-node[data-key="ios"] > .tree-header .tree-label {
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
        }

        .tree-count {
            margin-left: var(--nexus-spacing-3, 0.75rem);
            font: var(--nexus-caption-sm, 400 12px/1.6 Inter);
            color: var(--nexus-color-content-secondary, #575d69);
            background: var(--nexus-color-background-surface-tertiary, #d1d7e3);
            padding: var(--nexus-spacing-1, 0.125rem) var(--nexus-spacing-2, 0.5rem);
            border-radius: var(--nexus-shape-border-radius-round, 320px);
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            flex-shrink: 0;
        }

        .tree-children {
            display: none;
            list-style: none;
            padding: 0;
            margin: 0;
            padding-left: var(--nexus-spacing-6, 1.5rem);
            border-left: var(--nexus-shape-border-width-emphasized, 2px) solid var(--nexus-color-border-muted, #e4e8f2);
            margin-left: var(--nexus-spacing-2, 0.5rem);
            margin-top: var(--nexus-spacing-1, 0.25rem);
            margin-bottom: var(--nexus-spacing-1, 0.25rem);
            box-sizing: border-box;
        }

        .tree-children.expanded {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--nexus-spacing-2, 0.5rem);
        }

        /* Responsive grid: 1 -> 2 -> 3 -> 4 columns */
        @media (max-width: 768px) {
            .tree-children.expanded {
                grid-template-columns: 1fr;
            }
        }

        @media (min-width: 1200px) {
            .tree-children.expanded {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 1600px) {
            .tree-children.expanded {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        /* Branch nodes should span full width in the grid */
        .tree-node:has(.tree-header) {
            grid-column: 1 / -1;
        }

        .token-leaf {
            display: flex;
            flex-direction: column;
            padding: 0;
            margin: 0;
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            background: var(--nexus-color-background-surface-primary, #ffffff);
            transition: all 0.2s ease;
            cursor: pointer;
            overflow: hidden;
            min-width: 0;
            min-height: 0;
        }

        .token-leaf:hover {
            border-color: var(--nexus-color-border-focused, #3660d0);
            box-shadow: var(--nexus-effect-bottom-shadow-md, 0 2px 8px 0 rgba(0,0,0,0.12));
            transform: translateX(var(--nexus-shape-border-width-emphasized, 2px));
        }

        .token-leaf:active {
            transform: translateX(0);
            box-shadow: var(--nexus-effect-bottom-shadow-sm, 0 1px 4px 0 rgba(0,0,0,0.12));
        }

        .token-leaf-info {
            padding: var(--nexus-spacing-4, 1rem);
            display: flex;
            flex-direction: column;
            gap: var(--nexus-spacing-3, 0.75rem);
            flex: 1;
            min-width: 0;
        }

        .token-leaf-name {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-caption-sm-font-size, 0.75rem);
            line-height: 1.5;
            color: var(--nexus-color-content-primary, #17191c);
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            word-break: break-word;
            overflow-wrap: break-word;
            order: 1;
        }

        .token-leaf-reference {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-label-sm-font-size, 0.75rem);
            line-height: 1.5;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            color: var(--nexus-color-content-link, #172dbd);
            word-break: break-word;
            overflow-wrap: break-word;
            order: 2;
        }

        .token-leaf-value {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-caption-sm-font-size, 0.75rem);
            line-height: 1.5;
            font-weight: var(--nexus-typography-font-weight-regular, 400);
            color: var(--nexus-color-content-tertiary, #8a909e);
            word-break: break-word;
            overflow-wrap: break-word;
            order: 3;
        }

        .token-leaf-label-text {
            display: block;
            font-size: var(--nexus-text-token-label-sm-font-size, 0.75rem);
            line-height: 1.5;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            color: var(--nexus-color-content-secondary, #575d69);
            word-break: break-word;
            overflow-wrap: break-word;
            order: 1;
        }

        .token-leaf-category {
            display: inline;
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            color: var(--nexus-color-content-primary, #17191c);
            margin-left: var(--nexus-spacing-1, 0.25rem);
            white-space: nowrap;
        }

        .token-leaf-label {
            font-size: 0.625rem;
            line-height: 1.4;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--nexus-color-content-tertiary, #8a909e);
            margin-bottom: var(--nexus-spacing-1, 0.125rem);
        }

        .token-leaf-preview {
            width: 100%;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
            border-bottom: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            padding: var(--nexus-spacing-6, 1.5rem);
            position: relative;
        }

        .preview-swatch {
            width: 100%;
            height: 80px;
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            color: var(--nexus-color-content-primary, #17191c);
            position: relative;
        }

        .token-leaf-value[title] {
            cursor: help;
            border-bottom: var(--nexus-shape-border-width-default, 1px) dotted var(--nexus-color-content-secondary, #575d69);
        }

        .preview-opacity {
            width: 100%;
            height: 80px;
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            position: relative;
            background-image: 
                linear-gradient(45deg, var(--nexus-color-system-white, #ffffff) 25%, transparent 25%),
                linear-gradient(-45deg, var(--nexus-color-system-white, #ffffff) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, var(--nexus-color-system-white, #ffffff) 75%),
                linear-gradient(-45deg, transparent 75%, var(--nexus-color-system-white, #ffffff) 75%);
            background-size: var(--nexus-spacing-4, 1rem) var(--nexus-spacing-4, 1rem);
            background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
            background-color: var(--nexus-color-background-surface-tertiary, #e4e8f2);
        }

        .preview-opacity-overlay {
            position: absolute;
            inset: 0;
            background: var(--nexus-color-content-link, #172dbd);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
        }

        .preview-spacing {
            width: 100%;
            height: 80px;
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            border: var(--nexus-shape-border-width-emphasized, 2px) dashed var(--nexus-color-deep-blue-400, #6c90e5);
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .preview-spacing-box {
            background: var(--nexus-color-content-link, #172dbd);
            border-radius: var(--nexus-shape-border-radius-3xs, 2px);
        }

        .preview-radius {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-content-link, #172dbd);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            box-shadow: var(--nexus-effect-center-shadow-md, 0 0 12px 0 rgba(0,0,0,0.12));
        }

        .preview-border-width {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-background-surface-primary, #ffffff);
            border: solid var(--nexus-color-content-link, #172dbd);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            box-shadow: var(--nexus-effect-center-shadow-md, 0 0 12px 0 rgba(0,0,0,0.12));
        }

        .preview-shadow {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-background-surface-primary, #ffffff);
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
        }

        .preview-gradient {
            width: 100%;
            height: 80px;
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            background-size: cover;
        }

        .preview-weight {
            font-size: var(--nexus-text-token-h2-font-size, 2.5rem);
            font-weight: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            line-height: var(--nexus-text-token-h2-line-height, 1.2);
        }

        .preview-font-size {
            font-size: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            line-height: var(--nexus-text-token-h2-line-height, 1.2);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }

        .preview-font-family {
            font-size: var(--nexus-text-token-h3-font-size, 2rem);
            font-family: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            line-height: var(--nexus-text-token-h3-line-height, 1.2);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }

        .preview-line-height {
            width: 100%;
            font-size: inherit;
            line-height: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            padding: var(--nexus-spacing-2, 0.5rem);
            text-align: left;
            white-space: normal;
            word-wrap: break-word;
        }

        .preview-typography {
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            line-height: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            padding: var(--nexus-spacing-4, 1rem);
            display: flex;
            align-items: center;
            min-height: 60px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="section">
            <div class="section-header">
                <h2>Nexus Design Tokens</h2>
                <span class="token-count" id="token-count">0 tokens</span>
            </div>
            <div class="filter-bar">
                <div class="filter-top-row">
                    <div class="search-wrapper">
                        <input type="text" class="search-input" id="search" placeholder="Search tokens...">
                        <button class="search-clear" id="search-clear" title="Clear search">Ã—</button>
                    </div>
                    <div class="filter-actions">
                        <button class="filter-btn" id="expand-all">Expand All</button>
                        <button class="filter-btn" id="collapse-all">Collapse All</button>
                    </div>
                </div>
                <div class="filter-chips" id="filter-chips">
                    <button class="filter-chip active" data-category="all">All</button>
                </div>
            </div>
            <div class="token-tree-container">
                <ul class="token-tree" id="token-tree"></ul>
            </div>
        </div>
    </div>

    <script>
        /**
         * Token data structure conforming to DTCG specification
         * @typedef {Object} Token
         * @property {string} name - Token CSS variable name (e.g., "--nexus-color-blue-500")
         * @property {*} value - Token value (primitive for simple tokens, object for composite)
         * @property {*} [original] - Original token value before resolution
         * @property {string} [type] - DTCG token type (color, typography, dimension, shadow, etc.)
         * @property {boolean} [isComposite] - Whether token has composite structure ($type with $value object)
         * @property {Object} [typographyProps] - Typography composite properties (fontFamily, fontSize, fontWeight, lineHeight, letterSpacing)
         * @property {string[]} [path] - Tree path for hierarchical navigation
         */
        
        // Parse CSS custom properties and metadata
        let tokens = [];
        let tokenMetadata = {};
        
        // Fetch both CSS and metadata JSON
        Promise.all([
            fetch('dist/css/tokens.css').then(r => {
                if (!r.ok) throw new Error('Failed to load CSS');
                return r.text();
            }),
            fetch('dist/json/tokens-preserved.json').then(r => {
                if (!r.ok) throw new Error('Failed to load preserved tokens');
                return r.json();
            })
        ])
            .then(([css, preservedTokens]) => {
                console.log('Loaded CSS and preserved tokens successfully');
                
                // Parse CSS custom properties for reference
                const tokenRegex = /--([^:]+):\s*([^;]+);/g;
                const cssTokens = new Map();
                let match;
                
                while ((match = tokenRegex.exec(css)) !== null) {
                    const tokenName = `--${match[1].trim()}`;
                    const resolvedValue = match[2].trim();
                    cssTokens.set(tokenName, resolvedValue);
                }
                
                console.log(`Parsed ${cssTokens.size} tokens from CSS`);
                
                // Process preserved tokens recursively
                function processPreservedTokens(obj, path = []) {
                    for (const key in obj) {
                        if (key.startsWith('$')) continue; // Skip metadata at this level
                        
                        const value = obj[key];
                        const currentPath = [...path, key];
                        
                        if (value && typeof value === 'object') {
                            // Check if this is a composite token with $type
                            if (value.$type && value.$value) {
                                // Create kebab-case token name from path
                                // Replace spaces with hyphens, then convert to lowercase
                                const tokenName = `--${currentPath.map(p => p.replace(/\s+/g, '-')).join('-').toLowerCase()}`;
                                
                                // For boxShadow: prefer resolved value from CSS when available
                                let displayValue = value.$value;
                                if (value.$type === 'boxShadow' && cssTokens.has(tokenName)) {
                                    displayValue = cssTokens.get(tokenName);
                                }
                                
                                tokens.push({
                                    name: tokenName,
                                    value: displayValue,
                                    type: value.$type,
                                    isComposite: true,
                                    // For typography, store properties for rendering (keep original for composite display)
                                    ...(value.$type === 'typography' && {
                                        typographyProps: value.$value
                                    }),
                                    // For boxShadow, keep raw value for client-side conversion fallback
                                    ...(value.$type === 'boxShadow' && {
                                        boxShadowValue: value.$value
                                    })
                                });
                            } else {
                                // Not a token, recurse into nested group
                                processPreservedTokens(value, currentPath);
                            }
                        } else if (value !== undefined && value !== null) {
                            // Regular token (no $type wrapper)
                            // Replace spaces with hyphens in path segments
                            const tokenName = `--${currentPath.map(p => p.replace(/\s+/g, '-')).join('-').toLowerCase()}`;
                            
                            // Get resolved value from CSS if available
                            const resolvedValue = cssTokens.get(tokenName) || value;
                            
                            tokens.push({
                                name: tokenName,
                                value: resolvedValue,
                                original: value
                            });
                        }
                    }
                }
                
                processPreservedTokens(preservedTokens);
                
                console.log(`Processed ${tokens.length} tokens from preserved JSON`);
                
                // Build metadata map for reference tooltips
                function buildMetadataMap(obj, map, path = []) {
                    try {
                        if (obj && typeof obj === 'object') {
                            for (const key in obj) {
                                if (key.startsWith('$')) continue;
                                
                                const value = obj[key];
                                const currentPath = [...path, key];
                                
                                if (value && typeof value === 'object') {
                                    if (value.$value !== undefined) {
                                        const tokenName = `--${currentPath.join('-').toLowerCase()}`;
                                        map[tokenName] = {
                                            original: value.$value,
                                            type: value.$type
                                        };
                                    } else {
                                        buildMetadataMap(value, map, currentPath);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error building metadata map:', e);
                    }
                }
                buildMetadataMap(preservedTokens, tokenMetadata);
                
                console.log(`Built metadata for ${Object.keys(tokenMetadata).length} tokens`);
                
                // Initialize the UI after tokens are loaded
                initializeUI();
            })
            .catch(error => {
                console.error('Error loading tokens:', error);
                document.getElementById('token-tree').innerHTML = 
                    `<p style="text-align: center; color: #f32245; padding: 2rem;">Error loading tokens: ${error.message}<br>Make sure to run <code>npm run build</code> first and serve this page via a local server.</p>`;
            });
        
        function initializeUI() {
            // Config: extend when swapping token sets (Phase 5)
            const tokenViewerConfig = {
                compoundNames: {
                    'deep-blue': 'deepBlue', 'deep-green': 'deepGreen', 'bright-yellow': 'brightYellow',
                    'on-color': 'onColor', 'on-subtle': 'onSubtle', 'mid-blue': 'midBlue', 'mid-green': 'midGreen',
                    'new-sky': 'newSky', 'day-glow': 'dayGlow', 'action-lighter': 'actionLighter',
                    'action-light': 'actionLight', 'action-dark': 'actionDark', 'action-darker': 'actionDarker'
                },
                layerNames: { 'type': 'Text Style Preview', 'texttoken': 'Text Token Properties' },
                treeSortOrder: ['nexus', 'mui', 'ios'],
                categoryDisplayNames: {
                    color: 'Colors', opacity: 'Opacity', spacing: 'Spacing', sizing: 'Sizing',
                    typography: 'Typography', gradient: 'Gradients', effect: 'Effects',
                    'font-weight': 'Font Weight', 'font-family': 'Font Family', 'font-size': 'Font Size',
                    'line-height': 'Line Height', 'border-width': 'Border Width', 'border-radius': 'Border Radius',
                    other: 'Other'
                },
                defaultFilterCategories: ['color', 'opacity', 'spacing', 'sizing', 'typography', 'gradient', 'effect']
            };
            
            // Build hierarchical tree - PASSTHROUGH: mirrors source structure, no hardcoded categorization
            function buildTree(tokens) {
                const tree = {};
                
                function normalizeTokenName(tokenName) {
                    let name = tokenName.replace(/^--/, '');
                    for (const [compound, replacement] of Object.entries(tokenViewerConfig.compoundNames || {})) {
                        name = name.replace(compound, replacement);
                    }
                    return name;
                }
                
                tokens.forEach(token => {
                    const normalizedName = normalizeTokenName(token.name);
                    const path = normalizedName.split('-');
                    
                    let current = tree;
                    
                    // Navigate/create tree structure
                    for (let i = 0; i < path.length; i++) {
                        const part = path[i];
                        
                        if (i === path.length - 1) {
                            // Leaf node - store token data
                            // Preserve all token properties for rendering (type, isComposite, typographyProps, etc.)
                            if (!current._tokens) current._tokens = [];
                            current._tokens.push({
                                ...token,  // Spread all properties to maintain data integrity
                                path: path // Add tree-specific metadata
                            });
                        } else {
                            // Branch node
                            if (!current[part]) {
                                current[part] = {};
                            }
                            current = current[part];
                        }
                    }
                });
                
                return tree;
            }
            
            // Collapse folders that only contain a single child folder (no tokens)
            function collapseSingleChildFolders(node) {
                // Get all keys except _tokens
                const keys = Object.keys(node).filter(k => k !== '_tokens');
                
                // If this node has exactly one child and no tokens of its own
                if (keys.length === 1 && (!node._tokens || node._tokens.length === 0)) {
                    const childKey = keys[0];
                    const child = node[childKey];
                    
                    // Recursively collapse the child first
                    collapseSingleChildFolders(child);
                    
                    // Merge the child's contents into this node
                    Object.keys(child).forEach(key => {
                        node[key] = child[key];
                    });
                    
                    // Remove the now-redundant child folder
                    delete node[childKey];
                } else {
                    // Recursively process all children
                    keys.forEach(key => {
                        if (typeof node[key] === 'object') {
                            collapseSingleChildFolders(node[key]);
                        }
                    });
                }
                
                return node;
            }
            
            // Build typography style string and sample text for composite typography tokens
            function getTypographyDisplay(token) {
                if (!token.typographyProps) return null;
                const props = token.typographyProps;
                const styles = [];
                if (props.fontFamily) {
                    const fontFamily = props.fontFamily === 'Inter' 
                        ? "Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
                        : props.fontFamily;
                    styles.push(`font-family: ${fontFamily}`);
                }
                if (props.fontSize) {
                    const fontSize = typeof props.fontSize === 'number' ? `${props.fontSize}px` : props.fontSize;
                    styles.push(`font-size: ${fontSize}`);
                }
                if (props.fontWeight) {
                    const fontWeightMap = {
                        'thin': 100, 'hairline': 100, 'extra light': 200, 'extralight': 200,
                        'light': 300, 'normal': 400, 'regular': 400, 'medium': 500,
                        'semi bold': 600, 'semibold': 600, 'bold': 700,
                        'extra bold': 800, 'extrabold': 800, 'black': 900, 'heavy': 900
                    };
                    const weight = typeof props.fontWeight === 'string' 
                        ? (fontWeightMap[props.fontWeight.toLowerCase()] || props.fontWeight)
                        : props.fontWeight;
                    styles.push(`font-weight: ${weight}`);
                }
                if (props.lineHeight) styles.push(`line-height: ${props.lineHeight}`);
                if (props.letterSpacing) {
                    const spacing = props.letterSpacing === '0%' ? '0' : props.letterSpacing;
                    styles.push(`letter-spacing: ${spacing}`);
                }
                if (props.textDecoration) styles.push(`text-decoration: ${props.textDecoration}`);
                const styleStr = styles.join('; ');
                const isLink = props.textDecoration === 'underline' || (token.name && token.name.toLowerCase().includes('link'));
                const fontSizeNum = typeof props.fontSize === 'number' ? props.fontSize : parseFloat(props.fontSize);
                const lineHeightVal = props.lineHeight;
                const lineHeightNum = typeof lineHeightVal === 'string' ? parseFloat(lineHeightVal) : lineHeightVal;
                const useWrapText = !isLink && lineHeightNum >= 1.5;
                let sampleText;
                if (isLink) sampleText = 'Link text';
                else if (useWrapText) sampleText = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.';
                else if (fontSizeNum >= 24) sampleText = 'Heading';
                else if (fontSizeNum >= 18) sampleText = 'Subtitle text';
                else if (fontSizeNum >= 14) sampleText = 'The quick brown fox jumps over the lazy dog.';
                else sampleText = 'The quick brown fox';
                return { styleStr, sampleText };
            }
            
            // Convert DTCG boxShadow object/array to CSS string
            function boxShadowToCss(value) {
                const arr = Array.isArray(value) ? value : [value];
                return arr.map(shadow => {
                    const { x = 0, y = 0, blur = 0, spread = 0, color = '#000000' } = shadow;
                    const inset = shadow.type === 'innerShadow' ? 'inset ' : '';
                    return `${inset}${x}px ${y}px ${blur}px ${spread}px ${color}`;
                }).join(', ');
            }
            
            // Get token category for visual preview - TYPE-FIRST (DTCG), name fallback for tokens without $type
            function getTokenCategory(name, token) {
                const n = (name || '').toLowerCase();
                const t = token || {};
                const v = t.value;
                const type = (t.type || '').toLowerCase();
                
                // 1. Value shape (runs before generic color)
                if (typeof v === 'string' && v.includes('linear-gradient')) return 'gradient';
                
                // 2. DTCG type-driven (primary)
                if (type === 'gradient') return 'gradient';
                if (type === 'boxshadow' || type === 'shadow') return 'effect';
                if (type === 'typography') return 'typography';
                if (type === 'color') return 'color';
                if (type === 'fontweight' || type === 'font-weight' || (type === 'text' && (n.includes('fontweight') || n.includes('font-weight')))) return 'font-weight';
                if (type === 'fontfamily' || type === 'font-family' || (type === 'text' && (n.includes('fontfamily') || n.includes('font-family')))) return 'font-family';
                if (type === 'dimension') {
                    if (n.includes('lineheight') || n.includes('line-height')) return 'line-height';
                    if (n.includes('spacing')) return 'spacing';
                    if (n.includes('sizing') || n.includes('fontsize') || n.includes('font-size')) return n.includes('font') ? 'font-size' : 'sizing';
                    return n.includes('spacing') ? 'spacing' : 'sizing';
                }
                if (type === 'number' && (n.includes('opacity') || n.includes('fontweight'))) {
                    return n.includes('font') ? 'font-weight' : 'opacity';
                }
                
                // 3. Name-based fallback (tokens without $type, e.g. from CSS)
                if (n.includes('gradient')) return 'gradient';
                if (n.includes('effect') || n.includes('shadow')) return 'effect';
                if (n.includes('surface') && n.includes('color')) return 'effect';
                if (n.includes('color')) return 'color';
                if (n.includes('opacity')) return 'opacity';
                if (n.includes('spacing')) return 'spacing';
                if (n.includes('sizing')) return 'sizing';
                if (n.includes('font-weight') || n.includes('fontweight')) return 'font-weight';
                if (n.includes('font-size') || n.includes('fontsize')) return 'font-size';
                if (n.includes('font-family') || n.includes('fontfamily')) return 'font-family';
                if (n.includes('line-height') || n.includes('lineheight')) return 'line-height';
                if (n.includes('typography') || n.includes('text-token')) return 'typography';
                if (n.includes('border-width') || n.includes('borderwidth')) return 'border-width';
                if (n.includes('shape') || n.includes('radius') || n.includes('border-radius')) return 'border-radius';
                return 'other';
            }
            
            // Render preview based on token category
            function renderPreview(token) {
                // Check if this is a composite token with type metadata
                if (token.isComposite && token.type === 'typography' && token.typographyProps) {
                    const display = getTypographyDisplay(token);
                    if (!display) return `<div class="token-leaf-preview"><div class="preview-typography">No preview</div></div>`;
                    const { styleStr, sampleText } = display;
                    const previewContent = `<div class="preview-typography" style="${styleStr}">${sampleText}</div>`;
                    return `<div class="token-leaf-preview">${previewContent}</div>`;
                }
                
                const category = getTokenCategory(token.name, token);
                let previewContent = '';
                
                switch (category) {
                    case 'color':
                        previewContent = `<div class="preview-swatch" style="background-color: ${token.value};"></div>`;
                        break;
                    
                    case 'opacity':
                        // Normalize opacity values: numbers (32, 24) -> 0.32, 0.24; strings ("56px") -> 0.56
                        let opacityValue = token.value;
                        if (typeof opacityValue === 'string') {
                            // Remove "px" and convert to number
                            opacityValue = parseFloat(opacityValue.replace('px', ''));
                        }
                        if (typeof opacityValue === 'number' && opacityValue > 1) {
                            // Convert from 0-100 range to 0-1 range
                            opacityValue = opacityValue / 100;
                        }
                        previewContent = `<div class="preview-opacity"><div class="preview-opacity-overlay" style="opacity: ${opacityValue};"></div></div>`;
                        break;
                    
                    case 'spacing':
                    case 'sizing':
                        // Show a box with the actual dimension
                        const size = token.value;
                        previewContent = `<div class="preview-spacing"><div class="preview-spacing-box" style="width: ${size}; height: ${size};"></div></div>`;
                        break;
                    
                    case 'border-radius':
                        // Ensure the value has units (px if it's a number)
                        const radiusValue = typeof token.value === 'number' ? `${token.value}px` : token.value;
                        previewContent = `<div class="preview-radius" style="border-radius: ${radiusValue};"></div>`;
                        break;
                    
                    case 'border-width':
                        const borderWidthValue = typeof token.value === 'number' ? `${token.value}px` : token.value;
                        previewContent = `<div class="preview-border-width" style="border-width: ${borderWidthValue};"></div>`;
                        break;
                    
                    case 'font-weight':
                        const fontWeightValue = (() => {
                            const v = token.value;
                            if (typeof v === 'number') return v;
                            const map = { 'thin': 100, 'light': 300, 'regular': 400, 'medium': 500, 'semibold': 600, 'bold': 700 };
                            return map[String(v).toLowerCase()] || v;
                        })();
                        previewContent = `<div class="preview-weight" style="font-weight: ${fontWeightValue};">Ag</div>`;
                        break;
                    
                    case 'font-size':
                        const fontSizeValue = typeof token.value === 'number' ? `${token.value}px` : token.value;
                        previewContent = `<div class="preview-font-size" style="font-size: ${fontSizeValue};">Ag</div>`;
                        break;
                    
                    case 'font-family':
                        previewContent = `<div class="preview-font-family" style="font-family: ${token.value};">Ag</div>`;
                        break;
                    
                    case 'line-height':
                        // Paragraph-style preview: multiple lines to show line-height spacing
                        let lineHeightValue = token.value;
                        if (typeof lineHeightValue === 'string' && lineHeightValue.endsWith('px')) {
                            const num = parseFloat(lineHeightValue);
                            if (num >= 0.5 && num <= 3) lineHeightValue = String(num);
                        }
                        previewContent = `<div class="preview-line-height" style="line-height: ${lineHeightValue}; font-size: 1rem;">
                            The quick brown fox jumps over the lazy dog. Lorem ipsum dolor sit amet, consectetur adipiscing elit.
                        </div>`;
                        break;
                    
                    case 'typography':
                        // Fallback for typography tokens missing composite properties
                        if (typeof token.value === 'object') {
                            console.warn(`Typography token ${token.name} has object value but missing composite metadata`);
                            previewContent = `<div style="font-size: 0.75rem; color: var(--nexus-color-content-tertiary, #8a909e);">Typography (metadata missing)</div>`;
                        } else {
                            previewContent = `<div class="preview-typography" style="font: ${token.value};">The quick brown fox</div>`;
                        }
                        break;
                    
                    case 'gradient':
                        previewContent = `<div class="preview-gradient" style="background: ${token.value};"></div>`;
                        break;
                    
                    case 'effect':
                        // Type-driven: boxShadow/shadow -> shadow preview; color (surface) -> color swatch
                        const isShadowType = token.type === 'boxShadow' || token.type === 'shadow' || (typeof token.value === 'object' && (Array.isArray(token.value) || (token.value && 'blur' in token.value)));
                        if (isShadowType || token.boxShadowValue) {
                            const shadowCss = typeof token.value === 'string' ? token.value : (token.boxShadowValue ? boxShadowToCss(token.boxShadowValue) : '');
                            previewContent = `<div class="preview-shadow" style="box-shadow: ${shadowCss};"></div>`;
                        } else {
                            previewContent = `<div class="preview-swatch" style="background-color: ${token.value};"></div>`;
                        }
                        break;
                    
                    default:
                        previewContent = `<div style="font-size: 0.75rem; color: var(--nexus-color-content-tertiary, #8a909e);">No preview</div>`;
                }
                
                return `<div class="token-leaf-preview">${previewContent}</div>`;
            }
            
            // Render tree node recursively
            function renderTreeNode(key, node, depth = 0) {
                const li = document.createElement('li');
                li.className = 'tree-node';
                li.setAttribute('data-key', key.toLowerCase());
                
                // Check if this node has children or tokens
                const hasChildren = Object.keys(node).some(k => k !== '_tokens');
                const hasTokens = node._tokens && node._tokens.length > 0;
                
                if (hasChildren || hasTokens) {
                    const header = document.createElement('div');
                    header.className = 'tree-header';
                    
                    const toggle = document.createElement('span');
                    toggle.className = 'tree-toggle';
                    toggle.textContent = 'â–¶';
                    
                    const label = document.createElement('span');
                    label.className = 'tree-label';
                    
                    // Display name: optional overrides, else title-case the key
                    const layerOverrides = tokenViewerConfig.layerNames || {};
                    const displayKey = key.toLowerCase().replace(/\s+/g, '-');
                    label.textContent = layerOverrides[displayKey] || key.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                    
                    const count = document.createElement('span');
                    count.className = 'tree-count';
                    const totalCount = countTokens(node);
                    count.textContent = `${totalCount}`;
                    
                    header.appendChild(toggle);
                    header.appendChild(label);
                    header.appendChild(count);
                    
                    const childrenUl = document.createElement('ul');
                    childrenUl.className = 'tree-children';
                    
                    const childKeys = Object.keys(node).filter(k => k !== '_tokens');
                    const sortOrder = tokenViewerConfig.treeSortOrder || [];
                    const sortedChildKeys = childKeys.sort((a, b) => {
                        const aLower = a.toLowerCase();
                        const bLower = b.toLowerCase();
                        const aIndex = sortOrder.indexOf(aLower);
                        const bIndex = sortOrder.indexOf(bLower);
                        if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                        if (aIndex !== -1) return -1;
                        if (bIndex !== -1) return 1;
                        return aLower.localeCompare(bLower);
                    });
                    
                    // Render child branches
                    sortedChildKeys.forEach(childKey => {
                        childrenUl.appendChild(renderTreeNode(childKey, node[childKey], depth + 1));
                    });
                    
                    // Render leaf tokens
                    if (hasTokens) {
                        node._tokens.forEach(token => {
                            const tokenLi = document.createElement('li');
                            tokenLi.className = 'tree-node';
                            
                            // Check if we have metadata for this token
                            const metadata = tokenMetadata[token.name];
                            const originalValue = metadata?.original || token.value;
                            let resolvedValue = token.value;
                            
                            // Special handling for composite typography tokens - show styled sample instead of raw values
                            let typographyDisplay = null;
                            if (token.isComposite && token.type === 'typography' && token.typographyProps) {
                                typographyDisplay = getTypographyDisplay(token);
                            }
                            
                            // Check if this token references another token
                            const isReference = String(originalValue).includes('{') && String(originalValue).includes('}');
                            
                            // Build the card: 1) VISUAL PREVIEW (hero), 2) TOKEN NAME, 3) REFERENCE (if exists), 4) RESOLVED VALUE or styled sample
                            let infoHTML = '';
                            
                            if (typographyDisplay) {
                                // For typography tokens: preview shows the style; label uses consistent label style (no inheritance)
                                // Include last segment (e.g. "subtle", "h1") for legibility within each category
                                const segments = token.name.replace(/^--/, '').split('-');
                                const lastSegment = segments.length ? segments[segments.length - 1] : '';
                                const friendlyLabel = lastSegment ? (lastSegment.match(/^h[1-6]$/i) ? lastSegment.toUpperCase() : lastSegment.charAt(0).toUpperCase() + lastSegment.slice(1)) : '';
                                infoHTML = `
                                    <div class="token-leaf-label-text">${token.name}${friendlyLabel ? ` <span class="token-leaf-category">Â· ${friendlyLabel}</span>` : ''}</div>
                                `;
                            } else if (isReference) {
                                // Show token name, then reference, then resolved value
                                infoHTML = `
                                    <div class="token-leaf-name">${token.name}</div>
                                    <div class="token-leaf-reference">${originalValue}</div>
                                    <div class="token-leaf-value">â†’ ${resolvedValue}</div>
                                `;
                            } else {
                                // Show token name, then value directly
                                infoHTML = `
                                    <div class="token-leaf-name">${token.name}</div>
                                    <div class="token-leaf-value">${resolvedValue}</div>
                                `;
                            }
                            
                            const tokenCategory = getTokenCategory(token.name, token);
                            tokenLi.innerHTML = `
                                <div class="token-leaf" data-category="${tokenCategory}">
                                    ${renderPreview(token)}
                                    <div class="token-leaf-info">
                                        ${infoHTML}
                                    </div>
                                </div>
                            `;
                            childrenUl.appendChild(tokenLi);
                        });
                    }
                    
                    // Toggle expand/collapse
                    header.addEventListener('click', () => {
                        const isExpanded = childrenUl.classList.contains('expanded');
                        if (isExpanded) {
                            childrenUl.classList.remove('expanded');
                            toggle.classList.remove('expanded');
                        } else {
                            childrenUl.classList.add('expanded');
                            toggle.classList.add('expanded');
                        }
                    });
                    
                    li.appendChild(header);
                    li.appendChild(childrenUl);
                }
                
                return li;
            }
            
            // Count total tokens in a branch
            function countTokens(node) {
                let count = 0;
                if (node._tokens) count += node._tokens.length;
                Object.keys(node).forEach(key => {
                    if (key !== '_tokens') {
                        count += countTokens(node[key]);
                    }
                });
                return count;
            }
            
            // Build and render the tree
            const tree = buildTree(tokens);
            
            // Collapse any folders that only contain a single child folder
            Object.keys(tree).forEach(key => {
                collapseSingleChildFolders(tree[key]);
            });
            
            const treeContainer = document.getElementById('token-tree');
            
            // Custom sort order for top-level categories
            const sortOrder = tokenViewerConfig.treeSortOrder || [];
            const sortedKeys = Object.keys(tree).sort((a, b) => {
                const aLower = a.toLowerCase();
                const bLower = b.toLowerCase();
                const aIndex = sortOrder.indexOf(aLower);
                const bIndex = sortOrder.indexOf(bLower);
                
                // If both are in the priority list, sort by their position
                if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                // If only a is in the list, it comes first
                if (aIndex !== -1) return -1;
                // If only b is in the list, it comes first
                if (bIndex !== -1) return 1;
                // Otherwise, alphabetical sort
                return aLower.localeCompare(bLower);
            });
            
            sortedKeys.forEach(key => {
                treeContainer.appendChild(renderTreeNode(key, tree[key]));
            });
            
            // Update token count
            document.getElementById('token-count').textContent = `${tokens.length} tokens`;
            
            // Dynamic filter chips - built from actual token categories
            const filterChipsContainer = document.getElementById('filter-chips');
            const categories = new Set();
            tokens.forEach(t => categories.add(getTokenCategory(t.name, t)));
            const categoryList = tokens.length > 0
                ? Array.from(categories).filter(c => c !== 'other').sort((a, b) => {
                    const order = ['color', 'typography', 'gradient', 'effect', 'opacity', 'spacing', 'sizing', 'font-weight', 'font-family', 'font-size', 'line-height', 'border-width', 'border-radius'];
                    const ai = order.indexOf(a);
                    const bi = order.indexOf(b);
                    if (ai !== -1 && bi !== -1) return ai - bi;
                    if (ai !== -1) return -1;
                    if (bi !== -1) return 1;
                    return a.localeCompare(b);
                })
                : (tokenViewerConfig.defaultFilterCategories || []);
            const displayNames = tokenViewerConfig.categoryDisplayNames || {};
            filterChipsContainer.innerHTML = '<button class="filter-chip active" data-category="all">All</button>' +
                categoryList.map(cat => {
                    const label = displayNames[cat] || cat.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    return `<button class="filter-chip" data-category="${cat}">${label}</button>`;
                }).join('');
            
            // Expand/Collapse All functionality
            document.getElementById('expand-all').addEventListener('click', () => {
                document.querySelectorAll('.tree-children').forEach(el => {
                    el.classList.add('expanded');
                });
                document.querySelectorAll('.tree-toggle').forEach(el => {
                    el.classList.add('expanded');
                });
            });
            
            document.getElementById('collapse-all').addEventListener('click', () => {
                document.querySelectorAll('.tree-children').forEach(el => {
                    el.classList.remove('expanded');
                });
                document.querySelectorAll('.tree-toggle').forEach(el => {
                    el.classList.remove('expanded');
                });
            });
            
            // Filter chip functionality
            let activeCategory = 'all';
            const filterChips = document.querySelectorAll('.filter-chip');
            
            filterChips.forEach(chip => {
                chip.addEventListener('click', () => {
                    // Update active state
                    filterChips.forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    
                    // Get selected category
                    activeCategory = chip.dataset.category;
                    
                    // Apply filter
                    applyFilters();
                });
            });
            
            // Search functionality
            const searchInput = document.getElementById('search');
            const searchClear = document.getElementById('search-clear');
            
            searchInput.addEventListener('input', () => {
                // Show/hide clear button based on input
                if (searchInput.value) {
                    searchClear.classList.add('visible');
                } else {
                    searchClear.classList.remove('visible');
                }
                applyFilters();
            });
            
            searchClear.addEventListener('click', () => {
                searchInput.value = '';
                searchClear.classList.remove('visible');
                applyFilters();
                searchInput.focus();
            });
            
            // Combined filter function
            function applyFilters() {
                const searchTerm = searchInput.value.toLowerCase();
                const leaves = document.querySelectorAll('.token-leaf');
                
                // First pass: Show/hide token leaves based on filters
                leaves.forEach(leaf => {
                    const nameEl = leaf.querySelector('.token-leaf-name') || leaf.querySelector('.token-leaf-label-text');
                    const name = nameEl ? nameEl.textContent.toLowerCase() : '';
                    const category = leaf.dataset?.category || getTokenCategory(name);
                    
                    const matchesSearch = name.includes(searchTerm) || searchTerm === '';
                    const matchesCategory = activeCategory === 'all' || category === activeCategory;
                    
                    leaf.parentElement.style.display = matchesSearch && matchesCategory ? 'block' : 'none';
                });
                
                // Second pass: Show/hide tree branches based on visible children
                // Process from bottom up to ensure parent visibility is correct
                const allTreeNodes = Array.from(document.querySelectorAll('.tree-node')).reverse();
                
                allTreeNodes.forEach(node => {
                    const childrenContainer = node.querySelector(':scope > .tree-children');
                    
                    if (childrenContainer) {
                        // Check if this branch has any visible descendants
                        const hasVisibleDescendants = Array.from(childrenContainer.querySelectorAll('.token-leaf')).some(
                            leaf => leaf.parentElement.style.display !== 'none'
                        ) || Array.from(childrenContainer.querySelectorAll(':scope > .tree-node')).some(
                            childNode => childNode.style.display !== 'none'
                        );
                        
                        if (hasVisibleDescendants) {
                            node.style.display = 'block';
                            // Auto-expand parent trees that have matching results
                            if (searchTerm) {
                                childrenContainer.classList.add('expanded');
                            }
                        } else {
                            node.style.display = 'none';
                        }
                    } else {
                        // Leaf node (contains token-leaf), already handled in first pass
                    }
                });
                
                // If no filters active, show everything and collapse all
                if (!searchTerm && activeCategory === 'all') {
                    document.querySelectorAll('.tree-node').forEach(node => {
                        node.style.display = 'block';
                    });
                    // Collapse all when clearing search
                    document.querySelectorAll('.tree-children').forEach(container => {
                        container.classList.remove('expanded');
                    });
                }
            }
        }
    </script>
</body>
</html>
