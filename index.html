<!DOCTYPE html>
<html lang="en" data-alias="myq" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Design Tokens - Token Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="dist/css/tokens.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--nexus-typography-font-family-inter, Inter), -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: var(--nexus-text-token-body-md-default-font-size, 0.875rem);
            font-weight: var(--nexus-typography-font-weight-regular, 400);
            line-height: var(--nexus-text-token-body-md-default-line-height, 1.6);
            /* gradient-bg-light/dark don't switch with theme — apply manually via data-theme */
            background: var(--gradient-bg-light, linear-gradient(180deg, #e0eeff 0%, #f2f5fa 100%));
            color: var(--nexus-color-content-primary, #17191c);
            padding: var(--nexus-spacing-4, 1rem) var(--nexus-spacing-4, 1rem) 0 var(--nexus-spacing-4, 1rem);
        }
        [data-theme="dark"] body {
            background: var(--gradient-bg-dark, linear-gradient(180deg, #222429 0%, #0f0f0f 100%));
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            height: calc(100% - var(--nexus-spacing-8, 2rem));
            display: flex;
            flex-direction: column;
        }

        header {
            background: var(--nexus-color-background-surface-primary, #ffffff);
            padding: var(--nexus-spacing-8, 2rem);
            border-radius: var(--nexus-shape-border-radius-sm, 16px);
            margin-bottom: var(--nexus-spacing-8, 2rem);
            box-shadow: var(--nexus-effect-bottom-shadow-sm, 0 1px 4px 0 rgba(0,0,0,0.12));
        }

        h1 {
            font: var(--nexus-headings-h2, 600 28px/1.2 Inter);
            color: var(--nexus-color-content-link, #172dbd);
            margin-bottom: var(--nexus-spacing-2, 0.5rem);
        }

        .subtitle {
            font: var(--nexus-body-lg-subtle, 300 16px/1.6 Inter);
            color: var(--nexus-color-content-secondary, #575d69);
        }

        .stats {
            display: flex;
            gap: var(--nexus-spacing-6, 1.5rem);
            margin-top: var(--nexus-spacing-4, 1rem);
            flex-wrap: wrap;
        }

        .stat {
            background: transparent;
            padding: 0.5rem 0;
            border-radius: 0;
        }

        .stat-label {
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            color: var(--nexus-color-content-secondary, #575d69);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-value {
            font-size: var(--nexus-text-token-body-md-default-font-size, 0.875rem);
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            line-height: var(--nexus-text-token-body-md-default-line-height, 1.6);
            color: var(--nexus-color-content-secondary, #575d69);
        }

        .section {
            background: var(--nexus-color-background-surface-primary, #ffffff);
            padding: var(--nexus-spacing-8, 2rem);
            border-radius: var(--nexus-shape-border-radius-sm, 16px);
            box-shadow: var(--nexus-effect-bottom-shadow-sm, 0 1px 4px 0 rgba(0,0,0,0.12));
            display: flex;
            flex-direction: column;
            min-height: 0;
            flex: 1;
            margin: 0;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--nexus-spacing-3, 0.75rem);
            padding-bottom: var(--nexus-spacing-2, 0.5rem);
            border-bottom: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            flex-shrink: 0;
        }

        h2 {
            font: var(--nexus-headings-h6, 600 16px/1.2 Inter);
            color: var(--nexus-color-content-primary, #17191c);
            margin: 0;
        }

        .token-count {
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            color: var(--nexus-color-content-primary, #17191c);
            background: var(--nexus-color-background-surface-tertiary, #e4e8f2);
            padding: var(--nexus-spacing-1, 0.25rem) var(--nexus-sizing-62, 0.625rem);
            border-radius: var(--nexus-shape-border-radius-round, 320px);
        }

        .filter-bar {
            display: flex;
            flex-direction: column;
            gap: var(--nexus-spacing-3, 0.75rem);
            margin-bottom: var(--nexus-spacing-6, 1.5rem);
            flex-shrink: 0;
        }

        .token-tree-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }

        .token-tree {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .token-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--nexus-spacing-4, 1rem);
        }

        .token-card {
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            padding: var(--nexus-spacing-4, 1rem);
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            transition: all 0.2s;
        }

        .token-card:hover {
            border-color: var(--nexus-color-border-focused, #3660d0);
            box-shadow: var(--nexus-effect-bottom-shadow-md, 0 2px 8px 0 rgba(0,0,0,0.12));
        }

        .token-name {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-caption-sm-font-size, 0.75rem);
            color: var(--nexus-color-content-secondary, #575d69);
            margin-bottom: var(--nexus-spacing-2, 0.5rem);
            word-break: break-all;
        }

        .token-value {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-body-md-default-font-size, 0.875rem);
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            color: var(--nexus-color-content-primary, #17191c);
            margin-bottom: var(--nexus-spacing-3, 0.75rem);
        }

        .color-swatch {
            width: 100%;
            height: 60px;
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            margin-bottom: var(--nexus-spacing-2, 0.5rem);
        }

        .opacity-bar {
            width: 100%;
            height: 40px;
            background: linear-gradient(90deg, 
                var(--nexus-color-content-link, #172dbd) 0%, 
                transparent 100%);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            position: relative;
        }

        .opacity-marker {
            position: absolute;
            height: 100%;
            width: var(--nexus-shape-border-width-emphasized, 2px);
            background: var(--nexus-color-system-error-600, #f32245);
            top: 0;
        }

        .spacing-box {
            background: var(--nexus-color-background-primary-subtle, #e0ebff);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            display: flex;
            align-items: center;
            justify-content: center;
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            color: var(--nexus-color-foreground-primary-on-subtle, #17289c);
        }

        .font-weight-sample {
            font-size: var(--nexus-text-token-h5-font-size, 1.5rem);
            padding: var(--nexus-spacing-2, 0.5rem);
            text-align: center;
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
        }

        .filter-bar {
            display: flex;
            flex-direction: column;
            gap: var(--nexus-spacing-3, 0.75rem);
            margin-bottom: var(--nexus-spacing-6, 1.5rem);
        }

        .filter-top-row {
            display: flex;
            gap: var(--nexus-spacing-3, 0.75rem);
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-chips {
            display: flex;
            gap: var(--nexus-spacing-2, 0.5rem);
            flex-wrap: wrap;
        }

        /* Filter chips: semantic palette only — works in light and dark modes */
        .filter-chip {
            padding: var(--nexus-spacing-2, 0.5rem) var(--nexus-spacing-4, 1rem);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            border-radius: var(--nexus-shape-border-radius-round, 320px);
            background: var(--nexus-color-background-surface-primary, #ffffff);
            color: var(--nexus-color-content-secondary, #575d69);
            cursor: pointer;
            font: var(--nexus-label-md, 500 14px/1 Inter);
            transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
            user-select: none;
        }

        .filter-chip:hover {
            background: var(--nexus-color-background-surface-subtle, #e4e8f2);
            color: var(--nexus-color-content-primary, #17191c);
            border-color: var(--nexus-color-border-default, #babfcc);
        }

        .filter-chip:active {
            background: var(--nexus-color-background-surface-tertiary, #e4e8f2);
        }

        .filter-chip:focus-visible {
            outline: var(--nexus-shape-border-width-emphasized, 2px) solid var(--nexus-color-border-focused, #3660d0);
            outline-offset: 2px;
        }

        .filter-chip.active {
            background: var(--nexus-color-background-surface-inverse, #32363d);
            color: var(--nexus-color-content-on-color, #f2f5fa);
            border-color: var(--nexus-color-border-contrast, #222429);
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
        }

        .filter-chip.active:hover {
            background: var(--nexus-color-background-surface-inverse-dark, #222429);
            color: var(--nexus-color-content-on-color, #f2f5fa);
        }

        .filter-chip.active:focus-visible {
            outline-color: var(--nexus-color-border-focused, #3660d0);
        }

        .filter-actions {
            display: flex;
            gap: var(--nexus-spacing-2, 0.5rem);
        }

        .filter-btn {
            padding: var(--nexus-spacing-1, 0.25rem) var(--nexus-sizing-88, 0.875rem);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            background: var(--nexus-color-background-surface-primary, #ffffff);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            cursor: pointer;
            font: var(--nexus-label-md, 500 14px/1 Inter);
            transition: all 0.15s ease;
            color: var(--nexus-color-content-secondary, #575d69);
            white-space: nowrap;
        }

        .filter-btn:hover {
            border-color: var(--nexus-color-border-focused, #3660d0);
            color: var(--nexus-color-content-primary, #17191c);
        }

        .filter-btn:active {
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
        }

        .search-wrapper {
            position: relative;
            flex: 1;
            min-width: 200px;
        }

        .search-input {
            width: 100%;
            padding: var(--nexus-spacing-2, 0.5rem) 2.5rem var(--nexus-spacing-2, 0.5rem) var(--nexus-spacing-4, 1rem);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            font: var(--nexus-body-md-default, 400 14px/1.6 Inter);
            color: var(--nexus-color-content-primary, #17191c);
            background: var(--nexus-color-background-surface-primary, #ffffff);
        }

        .search-input::placeholder {
            color: var(--nexus-color-content-tertiary, #8a909e);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--nexus-color-border-focused, #3660d0);
        }

        .search-clear {
            position: absolute;
            right: var(--nexus-spacing-2, 0.5rem);
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--nexus-color-content-tertiary, #8a909e);
            cursor: pointer;
            padding: var(--nexus-spacing-1, 0.25rem);
            display: none;
            font-size: var(--nexus-text-token-body-lg-default-font-size, 1rem);
            line-height: 1;
            transition: color 0.15s ease;
        }

        .search-clear:hover {
            color: var(--nexus-color-content-primary, #17191c);
        }

        .search-clear.visible {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: var(--nexus-spacing-1, 0.125rem) var(--nexus-spacing-2, 0.5rem);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            margin-bottom: var(--nexus-spacing-2, 0.5rem);
        }

        .badge-color { background: var(--nexus-color-background-primary-subtle, #e0ebff); color: var(--nexus-color-deep-blue-700, #17289c); }
        .badge-opacity { background: var(--nexus-color-background-success-subtle, #e1fae7); color: var(--nexus-color-deep-green-600, #13ae5c); }
        .badge-spacing { background: var(--nexus-color-background-warning-subtle, #ffeedb); color: var(--nexus-color-yellow-700, #d78207); }
        .badge-sizing { background: var(--nexus-color-background-error-subtle, #ffe9e8); color: var(--nexus-color-red-700, #c61735); }
        .badge-typography { background: var(--nexus-color-background-secondary-subtle, #e0eeff); color: var(--nexus-color-blue-700, #05549e); }
        .badge-effect { background: var(--nexus-color-background-primary-subtle, #e0ebff); color: var(--nexus-color-deep-blue-800, #15227a); }
        .badge-surface { background: var(--nexus-color-background-surface-tertiary, #e4e8f2); color: var(--nexus-color-content-primary, #17191c); }
        .badge-gradient { background: var(--nexus-color-teal-100, #def7ff); color: var(--nexus-color-teal-600, #029bd1); }

        /* Tree View Styles */
        .tree-node {
            margin: 0;
            position: relative;
        }

        .tree-header {
            display: flex;
            align-items: center;
            padding: var(--nexus-sizing-62, 0.625rem) var(--nexus-spacing-3, 0.75rem);
            cursor: pointer;
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            transition: all 0.2s ease;
            user-select: none;
            margin: var(--nexus-shape-border-width-emphasized, 2px) 0;
            position: relative;
        }

        .tree-header:hover {
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
        }

        .tree-header:active {
            background: var(--nexus-color-background-surface-tertiary, #d1d7e3);
        }

        .tree-toggle {
            width: var(--nexus-sizing-112, 1.125rem);
            height: var(--nexus-sizing-112, 1.125rem);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 0.625rem;
            color: var(--nexus-color-content-secondary, #575d69);
            font-size: 0.625rem;
            transition: transform 0.15s ease;
            flex-shrink: 0;
        }

        .tree-toggle.expanded {
            transform: rotate(90deg);
        }

        .tree-label {
            font: var(--nexus-label-md, 500 14px/1 Inter);
            color: var(--nexus-color-content-primary, #17191c);
            flex: 1;
            min-width: 0;
        }

        /* Emphasis for specific top-level categories */
        .token-tree > .tree-node[data-key="nexus"] > .tree-header .tree-label,
        .token-tree > .tree-node[data-key="mui"] > .tree-header .tree-label,
        .token-tree > .tree-node[data-key="ios"] > .tree-header .tree-label {
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
        }

        .tree-count {
            margin-left: var(--nexus-spacing-3, 0.75rem);
            font: var(--nexus-caption-sm, 400 12px/1.6 Inter);
            color: var(--nexus-color-content-secondary, #575d69);
            background: var(--nexus-color-background-surface-tertiary, #e4e8f2);
            padding: var(--nexus-spacing-1, 0.125rem) var(--nexus-spacing-2, 0.5rem);
            border-radius: var(--nexus-shape-border-radius-round, 320px);
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            flex-shrink: 0;
        }

        .tree-children {
            display: none;
            list-style: none;
            padding: 0;
            margin: 0;
            padding-left: var(--nexus-spacing-6, 1.5rem);
            border-left: var(--nexus-shape-border-width-emphasized, 2px) solid var(--nexus-color-border-muted, #e4e8f2);
            margin-left: var(--nexus-spacing-2, 0.5rem);
            margin-top: var(--nexus-spacing-1, 0.25rem);
            margin-bottom: var(--nexus-spacing-1, 0.25rem);
            box-sizing: border-box;
        }

        .tree-children.expanded {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--nexus-spacing-2, 0.5rem);
        }

        /* Responsive grid: 1 -> 2 -> 3 -> 4 columns */
        @media (max-width: 768px) {
            .tree-children.expanded {
                grid-template-columns: 1fr;
            }
        }

        @media (min-width: 1200px) {
            .tree-children.expanded {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 1600px) {
            .tree-children.expanded {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        /* Branch nodes should span full width in the grid */
        .tree-node:has(.tree-header) {
            grid-column: 1 / -1;
        }

        .token-leaf {
            display: flex;
            flex-direction: column;
            padding: 0;
            margin: 0;
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            background: var(--nexus-color-background-surface-primary, #ffffff);
            transition: all 0.2s ease;
            cursor: pointer;
            overflow: hidden;
            min-width: 0;
            min-height: 0;
        }

        .token-leaf:hover {
            border-color: var(--nexus-color-border-focused, #3660d0);
            box-shadow: var(--nexus-effect-bottom-shadow-md, 0 2px 8px 0 rgba(0,0,0,0.12));
            transform: translateX(var(--nexus-shape-border-width-emphasized, 2px));
        }

        .token-leaf:active {
            transform: translateX(0);
            box-shadow: var(--nexus-effect-bottom-shadow-sm, 0 1px 4px 0 rgba(0,0,0,0.12));
        }

        .token-leaf-info {
            padding: var(--nexus-spacing-4, 1rem);
            display: flex;
            flex-direction: column;
            gap: var(--nexus-spacing-3, 0.75rem);
            flex: 1;
            min-width: 0;
        }

        .token-leaf-name {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-caption-sm-font-size, 0.75rem);
            line-height: 1.5;
            color: var(--nexus-color-content-primary, #17191c);
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            word-break: break-word;
            overflow-wrap: break-word;
            order: 1;
        }

        .token-leaf-reference {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-label-sm-font-size, 0.75rem);
            line-height: 1.5;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            color: var(--nexus-color-content-link, #172dbd);
            word-break: break-word;
            overflow-wrap: break-word;
            order: 2;
        }

        .token-leaf-value {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: var(--nexus-text-token-caption-sm-font-size, 0.75rem);
            line-height: 1.5;
            font-weight: var(--nexus-typography-font-weight-regular, 400);
            color: var(--nexus-color-content-tertiary, #8a909e);
            word-break: break-word;
            overflow-wrap: break-word;
            order: 3;
        }

        .token-leaf-label-text {
            display: block;
            font-size: var(--nexus-text-token-label-sm-font-size, 0.75rem);
            line-height: 1.5;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            color: var(--nexus-color-content-secondary, #575d69);
            word-break: break-word;
            overflow-wrap: break-word;
            order: 1;
        }

        .token-leaf-category {
            display: inline;
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
            color: var(--nexus-color-content-primary, #17191c);
            margin-left: var(--nexus-spacing-1, 0.25rem);
            white-space: nowrap;
        }

        .token-leaf-label {
            font-size: 0.625rem;
            line-height: 1.4;
            font-weight: var(--nexus-typography-font-weight-medium, 500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--nexus-color-content-tertiary, #8a909e);
            margin-bottom: var(--nexus-spacing-1, 0.125rem);
        }

        .token-leaf-preview {
            width: 100%;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--nexus-color-background-surface-secondary, #f2f5fa);
            border-bottom: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            padding: var(--nexus-spacing-6, 1.5rem);
            position: relative;
            overflow: visible;
        }

        .preview-swatch {
            width: 100%;
            height: 80px;
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            color: var(--nexus-color-content-primary, #17191c);
            position: relative;
        }

        .token-leaf-value[title] {
            cursor: help;
            border-bottom: var(--nexus-shape-border-width-default, 1px) dotted var(--nexus-color-border-default, #babfcc);
        }

        .preview-opacity {
            width: 100%;
            height: 80px;
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            position: relative;
            background-image: 
                linear-gradient(45deg, var(--nexus-color-system-white, #ffffff) 25%, transparent 25%),
                linear-gradient(-45deg, var(--nexus-color-system-white, #ffffff) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, var(--nexus-color-system-white, #ffffff) 75%),
                linear-gradient(-45deg, transparent 75%, var(--nexus-color-system-white, #ffffff) 75%);
            background-size: var(--nexus-spacing-4, 1rem) var(--nexus-spacing-4, 1rem);
            background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
            background-color: var(--nexus-color-background-surface-tertiary, #e4e8f2);
        }

        .preview-opacity-overlay {
            position: absolute;
            inset: 0;
            background: var(--nexus-color-content-link, #172dbd);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
        }

        .preview-spacing {
            width: 100%;
            min-height: 80px;
            max-height: 320px;
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            border: var(--nexus-shape-border-width-emphasized, 2px) dashed var(--nexus-color-border-focused, #3660d0);
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: auto;
        }

        .preview-spacing-box {
            flex-shrink: 0;
            background: var(--nexus-color-content-link, #172dbd);
            border-radius: var(--nexus-shape-border-radius-3xs, 2px);
        }

        .preview-radius {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-content-link, #172dbd);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            box-shadow: var(--nexus-effect-center-shadow-md, 0 0 12px 0 rgba(0,0,0,0.12));
        }

        .preview-border-width {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-background-surface-primary, #ffffff);
            border: solid var(--nexus-color-border-active, #172dbd);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            box-shadow: var(--nexus-effect-center-shadow-md, 0 0 12px 0 rgba(0,0,0,0.12));
        }

        .preview-shadow {
            width: 100%;
            height: 80px;
            background: var(--nexus-color-background-surface-primary, #ffffff);
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
        }

        .preview-gradient {
            width: 100%;
            height: 80px;
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            background-size: cover;
        }

        .preview-surface {
            width: 100%;
            height: 80px;
            border-radius: var(--nexus-shape-border-radius-xs, 8px);
            min-height: 80px;
        }

        .preview-weight {
            font-size: var(--nexus-text-token-h2-font-size, 2.5rem);
            font-weight: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            line-height: var(--nexus-text-token-h2-line-height, 1.2);
        }

        .preview-font-size {
            font-size: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            line-height: var(--nexus-text-token-h2-line-height, 1.2);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }

        .preview-font-family {
            font-size: var(--nexus-text-token-h3-font-size, 2rem);
            font-family: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            line-height: var(--nexus-text-token-h3-line-height, 1.2);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }

        .preview-line-height {
            width: 100%;
            font-size: inherit;
            line-height: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            padding: var(--nexus-spacing-2, 0.5rem);
            text-align: left;
            white-space: normal;
            word-wrap: break-word;
        }

        .preview-typography {
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            line-height: inherit;
            color: var(--nexus-color-content-primary, #17191c);
            padding: var(--nexus-spacing-4, 1rem);
            display: flex;
            align-items: center;
            min-height: 60px;
        }

        .preview-typography-single-line {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* App tabs: Token Viewer | Component Showcase */
        .app-tabs {
            display: flex;
            gap: 0;
            margin-bottom: var(--nexus-spacing-4, 1rem);
            border-bottom: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
        }
        .app-tab {
            padding: var(--nexus-spacing-2, 0.5rem) var(--nexus-spacing-4, 1rem);
            font: var(--nexus-label-md, 500 14px/1 Inter);
            color: var(--nexus-color-content-secondary, #575d69);
            background: none;
            border: none;
            border-bottom: var(--nexus-shape-border-width-emphasized, 2px) solid transparent;
            cursor: pointer;
            transition: color 0.15s ease, border-color 0.15s ease;
            margin-bottom: -1px;
        }
        .app-tab:hover {
            color: var(--nexus-color-content-primary, #17191c);
        }
        .app-tab.active {
            color: var(--nexus-color-content-link, #172dbd);
            border-bottom-color: var(--nexus-color-border-active, #172dbd);
            font-weight: var(--nexus-typography-font-weight-semibold, 600);
        }
        .app-panel {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        .app-panel.active {
            display: flex;
        }

        /* Alias theme dropdown */
        .alias-select-wrapper {
            display: flex;
            align-items: center;
            gap: var(--nexus-spacing-2, 0.5rem);
        }
        .alias-select-wrapper label {
            font: var(--nexus-label-sm, 500 12px/1 Inter);
            color: var(--nexus-color-content-secondary, #575d69);
            white-space: nowrap;
        }
        .alias-select {
            padding: var(--nexus-spacing-1, 0.25rem) var(--nexus-spacing-2, 0.5rem);
            padding-right: 2rem;
            border: var(--nexus-shape-border-width-default, 1px) solid var(--nexus-color-border-muted, #e4e8f2);
            border-radius: var(--nexus-shape-border-radius-xxs, 4px);
            font: var(--nexus-label-md, 500 14px/1 Inter);
            color: var(--nexus-color-content-primary, #17191c);
            background: var(--nexus-color-background-surface-primary, #ffffff);
            cursor: pointer;
            min-width: 120px;
        }
        .alias-select:hover {
            border-color: var(--nexus-color-border-focused, #3660d0);
        }
        .alias-select:focus {
            outline: none;
            border-color: var(--nexus-color-border-focused, #3660d0);
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="app-tabs" role="tablist" aria-label="App sections">
            <button class="app-tab active" role="tab" aria-selected="true" data-panel="token-viewer">Token Viewer</button>
            <button class="app-tab" role="tab" aria-selected="false" data-panel="component-showcase">Component Showcase</button>
        </nav>
        <div class="app-panel active" id="panel-token-viewer" role="tabpanel">
        <div class="section">
            <div class="section-header">
                <h2>Nexus Design Tokens</h2>
                <div style="display: flex; align-items: center; gap: var(--nexus-spacing-4, 1rem);">
                    <div class="alias-select-wrapper">
                        <label for="alias-select">Theme</label>
                        <select class="alias-select" id="alias-select" aria-label="Select alias theme">
                            <option value="myQ">myQ</option>
                            <option value="Community">Community</option>
                            <option value="LiftMaster Pro">LiftMaster Pro</option>
                            <option value="Enterprise">Enterprise</option>
                        </select>
                    </div>
                    <button class="filter-btn theme-toggle" id="theme-toggle" title="Toggle light/dark mode" aria-label="Toggle theme">☀️</button>
                    <span class="token-count" id="token-count">0 tokens</span>
                </div>
            </div>
            <div class="filter-bar">
                <div class="filter-top-row">
                    <div class="search-wrapper">
                        <input type="text" class="search-input" id="search" placeholder="Search tokens...">
                        <button class="search-clear" id="search-clear" title="Clear search">×</button>
                    </div>
                    <div class="filter-actions">
                        <button class="filter-btn" id="expand-all">Expand All</button>
                        <button class="filter-btn" id="collapse-all">Collapse All</button>
                    </div>
                </div>
                <div class="filter-chips" id="filter-chips">
                    <button class="filter-chip active" data-category="all">All</button>
                </div>
            </div>
            <div class="token-tree-container">
                <ul class="token-tree" id="token-tree"></ul>
            </div>
        </div>
        </div>
        <div class="app-panel section" id="panel-component-showcase" role="tabpanel">
            <div class="section-header">
                <h2>Component Showcase</h2>
            </div>
            <div class="component-showcase-content" style="flex: 1; display: flex; align-items: center; justify-content: center; color: var(--nexus-color-content-tertiary, #8a909e); font: var(--nexus-body-md-subtle, 400 14px/1.6 Inter);">
                Component showcase coming soon.
            </div>
        </div>
    </div>

    <script>
        /**
         * Token data structure conforming to DTCG specification
         * @typedef {Object} Token
         * @property {string} name - Token CSS variable name (e.g., "--nexus-color-blue-500")
         * @property {*} value - Token value (primitive for simple tokens, object for composite)
         * @property {*} [original] - Original token value before resolution
         * @property {string} [type] - DTCG token type (color, typography, dimension, shadow, etc.)
         * @property {boolean} [isComposite] - Whether token has composite structure ($type with $value object)
         * @property {Object} [typographyProps] - Typography composite properties (fontFamily, fontSize, fontWeight, lineHeight, letterSpacing)
         * @property {string[]} [path] - Tree path for hierarchical navigation
         */
        
        // Parse CSS custom properties and metadata
        let tokens = [];
        let tokensLight = [];
        let tokensDark = [];
        let tokenMetadata = {};
        let theme = localStorage.getItem('tokenViewerTheme') || 'light';
        function applyTheme() { document.documentElement.setAttribute('data-theme', theme); }
        function getTokenByName(arr, name) { return arr.find(t => t.name === name); }
        let reRenderTokenTree = null;
        const ALIASES = ['myQ', 'Community', 'LiftMaster Pro', 'Enterprise'];
        function aliasToSlug(a) { return a.toLowerCase().replace(/\s+/g, '-'); }
        let tokensByAlias = {}; // { slug: { light: [], dark: [], metadata: {} } }
        
        // Fetch combined CSS and all per-alias preserved JSON files
        const cssPromise = fetch('dist/css/tokens.css').then(r => {
            if (!r.ok) throw new Error('Failed to load CSS');
            return r.text();
        });
        const jsonPromises = ALIASES.flatMap(alias => {
            const slug = aliasToSlug(alias);
            return [
                fetch(`dist/json/tokens-preserved-${slug}-light.json`).then(r => r.ok ? r.json() : null),
                fetch(`dist/json/tokens-preserved-${slug}-dark.json`).then(r => r.ok ? r.json() : null)
            ];
        });
        
        Promise.all([cssPromise, ...jsonPromises])
            .then(([css, ...jsonResults]) => {
                console.log('Loaded CSS and preserved tokens for all aliases');
                
                // Parse CSS: extract [data-alias="X"] (light) and [data-theme="dark"][data-alias="X"] (dark) blocks per alias
                const tokenRegex = /--([^:]+):\s*([^;]+);/g;
                function parseCssBlock(content) {
                    const m = new Map();
                    let match;
                    tokenRegex.lastIndex = 0;
                    while ((match = tokenRegex.exec(content)) !== null) {
                        m.set(`--${match[1].trim()}`, match[2].trim());
                    }
                    return m;
                }
                
                const cssTokensByAlias = {};
                // Light blocks: [data-alias="X"] { } — NOT [data-theme="dark"][data-alias="X"]
                const lightBlockRe = /(?<!\[data-theme="dark"\])\[data-alias="([^"]+)"\]\s*\{([\s\S]*?)\}(?=\s*\[data-theme="dark"\]\[data-alias=|\s*\[data-alias=|\s*$)/g;
                const darkBlockRe = /\[data-theme="dark"\]\[data-alias="([^"]+)"\]\s*\{([\s\S]*?)\}(?=\s*\[data-alias=|\s*$)/g;
                let lm;
                while ((lm = lightBlockRe.exec(css)) !== null) {
                    cssTokensByAlias[lm[1]] = cssTokensByAlias[lm[1]] || {};
                    cssTokensByAlias[lm[1]].light = parseCssBlock(lm[2]);
                }
                while ((lm = darkBlockRe.exec(css)) !== null) {
                    cssTokensByAlias[lm[1]] = cssTokensByAlias[lm[1]] || {};
                    cssTokensByAlias[lm[1]].dark = parseCssBlock(lm[2]);
                }
                
                // Process preserved tokens recursively into target array
                for (let i = 0; i < ALIASES.length; i++) {
                    const alias = ALIASES[i];
                    const slug = aliasToSlug(alias);
                    const preservedLight = jsonResults[i * 2];
                    const preservedDark = jsonResults[i * 2 + 1];
                    const cssLight = (cssTokensByAlias[slug] || {}).light || new Map();
                    const cssDark = (cssTokensByAlias[slug] || {}).dark || new Map();
                    if (!preservedLight || !preservedDark) continue;
                    const arrLight = [], arrDark = [];
                    processPreservedTokens(preservedLight, cssLight, arrLight);
                    processPreservedTokens(preservedDark, cssDark, arrDark);
                    const meta = {};
                    buildMetadataMap(preservedLight, meta);
                    tokensByAlias[slug] = { light: arrLight, dark: arrDark, metadata: meta };
                }
                
                function processPreservedTokens(obj, cssTokens, targetArr, path = []) {
                    for (const key in obj) {
                        if (key.startsWith('$')) continue; // Skip metadata at this level
                        
                        const value = obj[key];
                        const currentPath = [...path, key];
                        
                        if (value && typeof value === 'object') {
                            // Check if this is a composite token with $type
                            if (value.$type && value.$value) {
                                // Create kebab-case token name from path
                                // Replace spaces with hyphens, then convert to lowercase
                                const tokenName = `--${currentPath.map(p => p.replace(/\s+/g, '-')).join('-').toLowerCase()}`;
                                
                                // Prefer resolved value from CSS when available (colors, boxShadow, etc.)
                                let displayValue = cssTokens.has(tokenName) ? cssTokens.get(tokenName) : value.$value;
                                
                                targetArr.push({
                                    name: tokenName,
                                    value: displayValue,
                                    type: value.$type,
                                    isComposite: true,
                                    // For typography, store properties for rendering (keep original for composite display)
                                    ...(value.$type === 'typography' && {
                                        typographyProps: value.$value
                                    }),
                                    // For boxShadow, keep raw value for client-side conversion fallback
                                    ...(value.$type === 'boxShadow' && {
                                        boxShadowValue: value.$value
                                    }),
                                    // For surface, store fill + effect for combined preview
                                    ...(value.$type === 'surface' && {
                                        surfaceProps: value.$value
                                    })
                                });
                            } else {
                                // Not a token, recurse into nested group
                                processPreservedTokens(value, cssTokens, targetArr, currentPath);
                            }
                        } else if (value !== undefined && value !== null) {
                            // Regular token (no $type wrapper)
                            // Replace spaces with hyphens in path segments
                            const tokenName = `--${currentPath.map(p => p.replace(/\s+/g, '-')).join('-').toLowerCase()}`;
                            
                            // Get resolved value from CSS if available
                            const resolvedValue = cssTokens.get(tokenName) || value;
                            
                            targetArr.push({
                                name: tokenName,
                                value: resolvedValue,
                                original: value
                            });
                        }
                    }
                }
                
                function buildMetadataMap(obj, map, path = []) {
                    try {
                        if (obj && typeof obj === 'object') {
                            for (const key in obj) {
                                if (key.startsWith('$')) continue;
                                const value = obj[key];
                                const currentPath = [...path, key];
                                if (value && typeof value === 'object') {
                                    if (value.$value !== undefined) {
                                        const tokenName = `--${currentPath.map(p => p.replace(/\s+/g, '-')).join('-').toLowerCase()}`;
                                        map[tokenName] = { original: value.$value, type: value.$type };
                                    } else {
                                        buildMetadataMap(value, map, currentPath);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error building metadata map:', e);
                    }
                }
                
                const activeAliasSlug = aliasToSlug(localStorage.getItem('tokenViewerAlias') || 'myQ');
                const aliasData = tokensByAlias[activeAliasSlug] || tokensByAlias['myq'] || Object.values(tokensByAlias)[0];
                if (aliasData) {
                    tokensLight.length = 0;
                    tokensLight.push(...aliasData.light);
                    tokensDark.length = 0;
                    tokensDark.push(...aliasData.dark);
                    tokens = tokensLight;
                    Object.assign(tokenMetadata, aliasData.metadata);
                }
                console.log(`Processed ${tokensLight.length} light, ${tokensDark.length} dark tokens for alias "${activeAliasSlug}"`);
                
                function applyAlias() {
                    const slug = aliasToSlug(localStorage.getItem('tokenViewerAlias') || 'myQ');
                    document.documentElement.setAttribute('data-alias', slug);
                }
                applyAlias();
                applyTheme();
                
                // Initialize the UI after tokens are loaded
                initializeUI();
            })
            .catch(error => {
                console.error('Error loading tokens:', error);
                document.getElementById('token-tree').innerHTML = 
                    `<p style="text-align: center; color: #f32245; padding: 2rem;">Error loading tokens: ${error.message}<br>Make sure to run <code>npm run build</code> first and serve this page via a local server.</p>`;
            });
        
        function initializeUI() {
            // Config: extend when swapping token sets (Phase 5)
            const tokenViewerConfig = {
                compoundNames: {
                    'deep-blue': 'deepBlue', 'deep-green': 'deepGreen', 'bright-yellow': 'brightYellow',
                    'on-color': 'onColor', 'on-subtle': 'onSubtle', 'mid-blue': 'midBlue', 'mid-green': 'midGreen',
                    'new-sky': 'newSky', 'day-glow': 'dayGlow', 'action-lighter': 'actionLighter',
                    'action-light': 'actionLight', 'action-dark': 'actionDark', 'action-darker': 'actionDarker',
                    'font-size': 'fontSize', 'font-weight': 'fontWeight', 'line-height': 'lineHeight',
                    'font-family': 'fontFamily', 'letter-spacing': 'letterSpacing', 'text-decoration': 'textDecoration',
                    'body-lg': 'bodyLg', 'body-md': 'bodyMd', 'body-sm': 'bodySm', 'caption-sm': 'captionSm', 'caption-lg': 'captionLg',
                    'label-sm': 'labelSm', 'label-md': 'labelMd', 'label-lg': 'labelLg', 'link-sm': 'linkSm', 'link-md': 'linkMd'
                },
                layerNames: {
                    'type': 'Text Style Preview', 'texttoken': 'Text Token Properties',
                    'typestyles': 'Type Styles', 'styles': 'Type Styles',
                    'headings': 'Headings', 'subtitle': 'Subtitle', 'body': 'Body',
                    'label': 'Label', 'caption': 'Caption', 'link': 'Link', 'button': 'Button'
                },
                treeSortOrder: ['nexus', 'mui', 'ios'],
                // Type Styles children: ensure Label and Caption appear as separate folders in correct order
                typeStylesSortOrder: ['headings', 'subtitle', 'body', 'label', 'caption', 'link', 'button'],
                categoryDisplayNames: {
                    color: 'Colors', opacity: 'Opacity', spacing: 'Spacing', sizing: 'Sizing',
                    typography: 'Typography', gradient: 'Gradients', surface: 'Surface', effect: 'Effects',
                    'font-weight': 'Font Weight', 'font-family': 'Font Family', 'font-size': 'Font Size',
                    'line-height': 'Line Height', 'border-width': 'Border Width', 'border-radius': 'Border Radius',
                    other: 'Other'
                },
                defaultFilterCategories: ['color', 'opacity', 'spacing', 'sizing', 'typography', 'gradient', 'surface', 'effect']
            };
            // Hide 01/02/03 source layers - tokens are already displayed in reorganized folders (Nexus, MUI, etc.)
            function isHiddenTreeKey(key) {
                if (!key) return false;
                const k = String(key).trim();
                return k === '01' || k === '02' || k === '03' || /^0[123]\s/.test(k);
            }
            
            // Build hierarchical tree - PASSTHROUGH: mirrors source structure, no hardcoded categorization
            function buildTree(tokens) {
                const tree = {};
                
                function normalizeTokenName(tokenName) {
                    let name = tokenName.replace(/^--/, '');
                    for (const [compound, replacement] of Object.entries(tokenViewerConfig.compoundNames || {})) {
                        name = name.replace(compound, replacement);
                    }
                    return name;
                }
                
                tokens.forEach(token => {
                    const normalizedName = normalizeTokenName(token.name);
                    const path = normalizedName.split('-');
                    
                    let current = tree;
                    
                    // Navigate/create tree structure
                    for (let i = 0; i < path.length; i++) {
                        const part = path[i];
                        
                        if (i === path.length - 1) {
                            // Leaf node - store token data
                            // Preserve all token properties for rendering (type, isComposite, typographyProps, etc.)
                            if (!current._tokens) current._tokens = [];
                            current._tokens.push({
                                ...token,  // Spread all properties to maintain data integrity
                                path: path // Add tree-specific metadata
                            });
                        } else {
                            // Branch node
                            if (!current[part]) {
                                current[part] = {};
                            }
                            current = current[part];
                        }
                    }
                });
                
                return tree;
            }
            
            // Folders to preserve (never collapse) - e.g. Label, Caption under Type Styles
            const PRESERVE_FOLDERS = ['label', 'caption', 'headings', 'subtitle', 'body', 'link', 'button'];
            // Collapse folders that only contain a single child folder (no tokens)
            function collapseSingleChildFolders(node) {
                // Get all keys except _tokens
                const keys = Object.keys(node).filter(k => k !== '_tokens');
                
                // If this node has exactly one child and no tokens of its own
                const childKey = keys[0];
                const shouldPreserveChild = childKey && PRESERVE_FOLDERS.includes(childKey.toLowerCase());
                if (keys.length === 1 && (!node._tokens || node._tokens.length === 0) && !shouldPreserveChild) {
                    const child = node[childKey];
                    
                    // Recursively collapse the child first
                    collapseSingleChildFolders(child);
                    
                    // Merge the child's contents into this node
                    Object.keys(child).forEach(key => {
                        node[key] = child[key];
                    });
                    
                    // Remove the now-redundant child folder
                    delete node[childKey];
                } else {
                    // Recursively process all children
                    keys.forEach(key => {
                        if (typeof node[key] === 'object') {
                            collapseSingleChildFolders(node[key]);
                        }
                    });
                }
                
                return node;
            }
            
            // Normalize lineHeight to unitless number (handles "120%", "1.2", 1.2)
            function parseLineHeight(val) {
                if (val == null) return null;
                const num = typeof val === 'number' ? val : parseFloat(val);
                if (isNaN(num)) return null;
                if (typeof val === 'string' && val.includes('%')) return num / 100;
                return num;
            }

            // Typography: synthesize typographyProps from sibling tokens (decomposed source)
            const TYPOGRAPHY_PROP_MAP = { 'font-size': 'fontSize', 'fontsize': 'fontSize', 'font-weight': 'fontWeight', 'fontweight': 'fontWeight', 'line-height': 'lineHeight', 'lineheight': 'lineHeight', 'font-family': 'fontFamily', 'fontfamily': 'fontFamily', 'letter-spacing': 'letterSpacing', 'letterspacing': 'letterSpacing', 'text-decoration': 'textDecoration', 'textdecoration': 'textDecoration' };
            const TYPOGRAPHY_PROP_SUFFIXES = ['font-size', 'fontsize', 'font-weight', 'fontweight', 'line-height', 'lineheight', 'font-family', 'fontfamily', 'letter-spacing', 'letterspacing', 'text-decoration', 'textdecoration'];
            function getTypographyPropsFromSiblings(token, tokensArr) {
                const name = (token.name || '').replace(/^--/, '').toLowerCase();
                let parentBase = null;
                for (const suf of TYPOGRAPHY_PROP_SUFFIXES) {
                    if (name.endsWith('-' + suf)) {
                        parentBase = name.slice(0, name.length - suf.length - 1);
                        break;
                    }
                }
                if (!parentBase) return null;
                const parentPrefix = parentBase + '-';
                const props = {};
                for (const t of tokensArr) {
                    const tn = (t.name || '').replace(/^--/, '').toLowerCase();
                    if (!tn.startsWith(parentPrefix) || tn === parentBase) continue;
                    const rest = tn.slice(parentPrefix.length);
                    const camelKey = TYPOGRAPHY_PROP_MAP[rest];
                    if (camelKey) props[camelKey] = t.value;
                }
                if (!props.fontSize && !props.fontFamily) return null;
                return Object.keys(props).length > 0 ? props : null;
            }
            function isTypographyGroup(tokens) {
                if (!tokens || tokens.length === 0) return false;
                const typoProps = TYPOGRAPHY_PROP_SUFFIXES;
                const allTypo = tokens.every(t => {
                    const n = (t.name || '').toLowerCase();
                    return typoProps.some(p => n.endsWith('-' + p));
                });
                if (!allTypo) return false;
                const first = (tokens[0].name || '').replace(/^--/, '').toLowerCase();
                const parentLen = first.lastIndexOf('-');
                if (parentLen < 0) return false;
                const parentPrefix = first.slice(0, parentLen);
                return tokens.every(t => {
                    const n = (t.name || '').replace(/^--/, '').toLowerCase();
                    return n.startsWith(parentPrefix + '-') && typoProps.some(p => n.endsWith('-' + p));
                });
            }
            function synthesizeTypographyToken(tokens, tokensArr) {
                const firstName = (tokens[0].name || '').replace(/^--/, '').toLowerCase();
                let parentBase = null;
                for (const suf of Object.keys(TYPOGRAPHY_PROP_MAP)) {
                    if (firstName.endsWith('-' + suf)) {
                        parentBase = firstName.slice(0, firstName.length - suf.length - 1);
                        break;
                    }
                }
                if (!parentBase) return tokens[0];
                const parentPrefix = parentBase + '-';
                const props = {};
                for (const t of tokens) {
                    const n = (t.name || '').replace(/^--/, '').toLowerCase();
                    if (!n.startsWith(parentPrefix)) continue;
                    const rest = n.slice(parentPrefix.length);
                    const camelKey = TYPOGRAPHY_PROP_MAP[rest];
                    if (camelKey) {
                        const themeToken = getTokenByName(tokensArr, t.name);
                        props[camelKey] = themeToken ? themeToken.value : t.value;
                    }
                }
                return { name: '--' + parentBase, typographyProps: props, type: 'typography', isComposite: true, value: '' };
            }
            /** True when we're in Text Style Preview (type > styles path) - collapse typography props into one card */
            function isInTextStylePreviewPath(nodePath) {
                const pathStr = (Array.isArray(nodePath) ? nodePath : []).join('.').toLowerCase();
                return pathStr.includes('type') && pathStr.includes('styles');
            }

            // Build typography style string and sample text for composite typography tokens
            // Scalable: single-line vs paragraph driven by lineHeight (tight < 1.4 = single-line)
            function getTypographyDisplay(token) {
                if (!token.typographyProps) return null;
                const props = token.typographyProps;
                const styles = [];
                if (props.fontFamily) {
                    const fontFamily = props.fontFamily === 'Inter' 
                        ? "Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
                        : props.fontFamily;
                    styles.push(`font-family: ${fontFamily}`);
                }
                if (props.fontSize) {
                    const fontSize = typeof props.fontSize === 'number' ? `${props.fontSize}px` : props.fontSize;
                    styles.push(`font-size: ${fontSize}`);
                }
                if (props.fontWeight) {
                    const fontWeightMap = {
                        'thin': 100, 'hairline': 100, 'extra light': 200, 'extralight': 200,
                        'light': 300, 'normal': 400, 'regular': 400, 'medium': 500,
                        'semi bold': 600, 'semibold': 600, 'bold': 700,
                        'extra bold': 800, 'extrabold': 800, 'black': 900, 'heavy': 900
                    };
                    const weight = typeof props.fontWeight === 'string' 
                        ? (fontWeightMap[props.fontWeight.toLowerCase()] || props.fontWeight)
                        : props.fontWeight;
                    styles.push(`font-weight: ${weight}`);
                }
                if (props.lineHeight) styles.push(`line-height: ${props.lineHeight}`);
                if (props.letterSpacing) {
                    const spacing = props.letterSpacing === '0%' ? '0' : props.letterSpacing;
                    styles.push(`letter-spacing: ${spacing}`);
                }
                if (props.textDecoration) styles.push(`text-decoration: ${props.textDecoration}`);
                const styleStr = styles.join('; ');
                const isLink = props.textDecoration === 'underline' || (token.name && token.name.toLowerCase().includes('link'));
                const lineHeightNum = parseLineHeight(props.lineHeight);
                // Single-line: tight leading (label, heading, button, subtitle) vs paragraph (body, caption)
                const isSingleLine = lineHeightNum != null && lineHeightNum < 1.4;
                const useWrapText = !isLink && (lineHeightNum == null || lineHeightNum >= 1.4);
                let sampleText;
                if (isLink) sampleText = 'Link text';
                else if (useWrapText) sampleText = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.';
                else sampleText = 'Sample text';
                return { styleStr, sampleText, singleLine: isSingleLine };
            }
            
            // Convert DTCG boxShadow object/array to CSS string
            function boxShadowToCss(value) {
                const arr = Array.isArray(value) ? value : [value];
                return arr.map(shadow => {
                    const { x = 0, y = 0, blur = 0, spread = 0, color = '#000000' } = shadow;
                    const inset = shadow.type === 'innerShadow' ? 'inset ' : '';
                    return `${inset}${x}px ${y}px ${blur}px ${spread}px ${color}`;
                }).join(', ');
            }
            
            // Get token category for visual preview - TYPE-FIRST (DTCG), name fallback for tokens without $type
            function getTokenCategory(name, token) {
                const n = (name || '').toLowerCase();
                const t = token || {};
                const v = t.value;
                const type = (t.type || '').toLowerCase();
                
                // 1. Value shape (runs before generic color)
                if (typeof v === 'string' && v.includes('linear-gradient')) return 'gradient';
                
                // 2. DTCG type-driven (primary)
                if (type === 'gradient') return 'gradient';
                if (type === 'surface') return 'surface';
                if (type === 'boxshadow' || type === 'shadow') return 'effect';
                if (type === 'typography') return 'typography';
                if (type === 'color') return 'color';
                if (type === 'fontweight' || type === 'font-weight' || (type === 'text' && (n.includes('fontweight') || n.includes('font-weight')))) return 'font-weight';
                if (type === 'fontfamily' || type === 'font-family' || (type === 'text' && (n.includes('fontfamily') || n.includes('font-family')))) return 'font-family';
                if (type === 'dimension') {
                    if (n.includes('lineheight') || n.includes('line-height')) return 'line-height';
                    if (n.includes('opacity')) return 'opacity';
                    if (n.includes('radius') || n.includes('borderradius') || n.includes('border-radius') || n.includes('corner')) return 'border-radius';
                    if (n.includes('borderwidth') || n.includes('border-width') || n.includes('stroke')) return 'border-width';
                    if (n.includes('spacing')) return 'spacing';
                    if (n.includes('sizing') || n.includes('fontsize') || n.includes('font-size')) return n.includes('font') ? 'font-size' : 'sizing';
                    return n.includes('spacing') ? 'spacing' : 'sizing';
                }
                if (type === 'opacity' || (type === 'number' && (n.includes('opacity') || n.includes('fontweight')))) {
                    return n.includes('font') ? 'font-weight' : 'opacity';
                }
                
                // 3. Name-based fallback (tokens without $type, e.g. from CSS)
                if (n.includes('gradient')) return 'gradient';
                if (n.includes('nexus-surface') || (n.includes('surface') && n.includes('effect'))) return 'surface';
                if (n.includes('effect') || n.includes('shadow')) return 'effect';
                if (n.includes('surface') && n.includes('color')) return 'effect';
                if (n.includes('color')) return 'color';
                if (n.includes('opacity')) return 'opacity';
                if (n.includes('spacing')) return 'spacing';
                if (n.includes('sizing')) return 'sizing';
                if (n.includes('font-weight') || n.includes('fontweight')) return 'font-weight';
                if (n.includes('font-size') || n.includes('fontsize')) return 'font-size';
                if (n.includes('font-family') || n.includes('fontfamily')) return 'font-family';
                if (n.includes('line-height') || n.includes('lineheight')) return 'line-height';
                if (n.includes('typography') || n.includes('text-token')) return 'typography';
                if (n.includes('border-width') || n.includes('borderwidth')) return 'border-width';
                if (n.includes('shape') || n.includes('radius') || n.includes('border-radius')) return 'border-radius';
                return 'other';
            }
            
            // Render preview based on token category
            function renderPreview(token) {
                // Typography: use typographyProps or synthesize from siblings (decomposed source)
                const tokensArr = theme === 'dark' ? tokensDark : tokensLight;
                const typographyProps = token.typographyProps || getTypographyPropsFromSiblings(token, tokensArr);
                if (typographyProps && (token.type === 'typography' || (token.name || '').toLowerCase().includes('typography'))) {
                    const display = getTypographyDisplay({ ...token, typographyProps });
                    if (!display) return `<div class="token-leaf-preview"><div class="preview-typography">No preview</div></div>`;
                    const { styleStr, sampleText, singleLine } = display;
                    const singleLineClass = singleLine ? ' preview-typography-single-line' : '';
                    const previewContent = `<div class="preview-typography${singleLineClass}" style="${styleStr}">${sampleText}</div>`;
                    return `<div class="token-leaf-preview">${previewContent}</div>`;
                }
                // Check if this is a composite token with type metadata
                if (token.isComposite && token.type === 'typography' && token.typographyProps) {
                    const display = getTypographyDisplay(token);
                    if (!display) return `<div class="token-leaf-preview"><div class="preview-typography">No preview</div></div>`;
                    const { styleStr, sampleText, singleLine } = display;
                    const singleLineClass = singleLine ? ' preview-typography-single-line' : '';
                    const previewContent = `<div class="preview-typography${singleLineClass}" style="${styleStr}">${sampleText}</div>`;
                    return `<div class="token-leaf-preview">${previewContent}</div>`;
                }
                
                // Surface: MUI elevation.bg + paper-overlay layered (consumption-layer only; source tokens unchanged)
                if (token.isComposite && token.type === 'surface' && token.surfaceProps) {
                    const n = (token.name || '').replace(/^--/, '').toLowerCase();
                    const overlayMap = {
                        'nexus-surface-sm': 'elevation-1',
                        'nexus-surface-md': 'elevation-2',
                        'nexus-surface-lg': 'elevation-4',
                        'nexus-surface-subtle': 'elevation-0',
                        'nexus-surface-outline': 'elevation-0'
                    };
                    const shadowMap = {
                        'nexus-surface-sm': 'var(--mui-effect-elevation-1)',
                        'nexus-surface-md': 'var(--mui-effect-elevation-2)',
                        'nexus-surface-lg': 'var(--mui-effect-elevation-4)',
                        'nexus-surface-subtle': 'var(--nexus-effect-bottom-shadow-subtle)',
                        'nexus-surface-outline': 'var(--mui-effect-elevation-0)'
                    };
                    const overlayKey = overlayMap[n];
                    const overlayVar = overlayKey ? `var(--mui-color-paper-overlay-${overlayKey}, transparent)` : 'transparent';
                    const shadowVar = shadowMap[n] || 'none';
                    const isOutline = n.includes('outline');
                    const borderCss = isOutline ? '1px solid var(--nexus-color-border-muted, #e4e8f2)' : 'none';
                    const bgVar = 'var(--mui-color-elevation-bg, #ffffff)';
                    const overlayGradient = overlayKey ? `linear-gradient(to bottom, ${overlayVar}, ${overlayVar})` : 'none';
                    const styleStr = `background-color: ${bgVar}; background-image: ${overlayGradient}; box-shadow: ${shadowVar}; border: ${borderCss};`;
                    return `<div class="token-leaf-preview"><div class="preview-surface" style="${styleStr}"></div></div>`;
                }
                
                const category = getTokenCategory(token.name, token);
                let previewContent = '';
                
                switch (category) {
                    case 'color':
                        previewContent = `<div class="preview-swatch" style="background-color: ${token.value};"></div>`;
                        break;
                    
                    case 'opacity':
                        // Normalize opacity: 0-100 -> 0-1; "32px" -> 0.32; 0.32 -> 0.32
                        let opacityValue = token.value;
                        if (typeof opacityValue === 'string') {
                            opacityValue = parseFloat(opacityValue.replace(/px|%/g, '')) || 0;
                        }
                        if (typeof opacityValue === 'number') {
                            if (opacityValue > 1) opacityValue = opacityValue / 100;
                            opacityValue = Math.max(0, Math.min(1, opacityValue));
                        }
                        previewContent = `<div class="preview-opacity"><div class="preview-opacity-overlay" style="opacity: ${opacityValue};"></div></div>`;
                        break;
                    
                    case 'spacing':
                    case 'sizing':
                        // Show a box with the actual dimension
                        const size = token.value;
                        previewContent = `<div class="preview-spacing"><div class="preview-spacing-box" style="width: ${size}; height: ${size};"></div></div>`;
                        break;
                    
                    case 'border-radius':
                        // Support number (add px), string with units (px, rem), or unitless 0
                        const radiusVal = token.value;
                        const radiusValue = radiusVal === 0 || radiusVal === '0' ? '0' : (typeof radiusVal === 'number' ? `${radiusVal}px` : String(radiusVal));
                        previewContent = `<div class="preview-radius" style="border-radius: ${radiusValue};"></div>`;
                        break;
                    
                    case 'border-width':
                        const widthVal = token.value;
                        const borderWidthValue = widthVal === 0 || widthVal === '0' ? '0' : (typeof widthVal === 'number' ? `${widthVal}px` : String(widthVal));
                        previewContent = `<div class="preview-border-width" style="border-width: ${borderWidthValue};"></div>`;
                        break;
                    
                    case 'font-weight':
                        const fontWeightValue = (() => {
                            const v = token.value;
                            if (typeof v === 'number') return v;
                            const map = { 'thin': 100, 'light': 300, 'regular': 400, 'medium': 500, 'semibold': 600, 'bold': 700 };
                            return map[String(v).toLowerCase()] || v;
                        })();
                        previewContent = `<div class="preview-weight" style="font-weight: ${fontWeightValue};">Ag</div>`;
                        break;
                    
                    case 'font-size':
                        const fontSizeValue = typeof token.value === 'number' ? `${token.value}px` : token.value;
                        previewContent = `<div class="preview-font-size" style="font-size: ${fontSizeValue};">Ag</div>`;
                        break;
                    
                    case 'font-family':
                        previewContent = `<div class="preview-font-family" style="font-family: ${token.value};">Ag</div>`;
                        break;
                    
                    case 'line-height':
                        // Paragraph-style preview: multiple lines to show line-height spacing
                        let lineHeightValue = token.value;
                        if (typeof lineHeightValue === 'string' && lineHeightValue.endsWith('px')) {
                            const num = parseFloat(lineHeightValue);
                            if (num >= 0.5 && num <= 3) lineHeightValue = String(num);
                        }
                        previewContent = `<div class="preview-line-height" style="line-height: ${lineHeightValue}; font-size: 1rem;">
                            The quick brown fox jumps over the lazy dog. Lorem ipsum dolor sit amet, consectetur adipiscing elit.
                        </div>`;
                        break;
                    
                    case 'typography':
                        // Fallback for typography tokens missing composite properties
                        if (typeof token.value === 'object') {
                            console.warn(`Typography token ${token.name} has object value but missing composite metadata`);
                            previewContent = `<div style="font-size: 0.75rem; color: var(--nexus-color-content-tertiary, #8a909e);">Typography (metadata missing)</div>`;
                        } else {
                            previewContent = `<div class="preview-typography" style="font: ${token.value};">The quick brown fox</div>`;
                        }
                        break;
                    
                    case 'gradient':
                        previewContent = `<div class="preview-gradient" style="background: ${token.value};"></div>`;
                        break;
                    
                    case 'effect':
                        // Type-driven: boxShadow/shadow -> shadow preview; color (surface) -> color swatch
                        const isShadowType = token.type === 'boxShadow' || token.type === 'shadow' || (typeof token.value === 'object' && (Array.isArray(token.value) || (token.value && 'blur' in token.value)));
                        if (isShadowType || token.boxShadowValue) {
                            const shadowCss = typeof token.value === 'string' ? token.value : (token.boxShadowValue ? boxShadowToCss(token.boxShadowValue) : '');
                            previewContent = `<div class="preview-shadow" style="box-shadow: ${shadowCss};"></div>`;
                        } else {
                            previewContent = `<div class="preview-swatch" style="background-color: ${token.value};"></div>`;
                        }
                        break;
                    
                    default:
                        previewContent = `<div style="font-size: 0.75rem; color: var(--nexus-color-content-tertiary, #8a909e);">No preview</div>`;
                }
                
                return `<div class="token-leaf-preview">${previewContent}</div>`;
            }
            
            // Render tree node recursively
            function renderTreeNode(key, node, depth = 0, path = []) {
                const li = document.createElement('li');
                li.className = 'tree-node';
                li.setAttribute('data-key', key.toLowerCase());
                const nodePath = [...path, key];
                const pathStr = nodePath.join('.');
                
                // Check if this node has children or tokens
                const hasChildren = Object.keys(node).some(k => k !== '_tokens');
                const hasTokens = node._tokens && node._tokens.length > 0;
                
                if (hasChildren || hasTokens) {
                    const header = document.createElement('div');
                    header.className = 'tree-header';
                    
                    const toggle = document.createElement('span');
                    toggle.className = 'tree-toggle';
                    toggle.textContent = '▶';
                    
                    const label = document.createElement('span');
                    label.className = 'tree-label';
                    
                    // Display name: optional overrides, else title-case the key
                    const layerOverrides = tokenViewerConfig.layerNames || {};
                    const displayKey = key.toLowerCase().replace(/\s+/g, '-');
                    label.textContent = layerOverrides[displayKey] || key.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                    
                    const count = document.createElement('span');
                    count.className = 'tree-count';
                    const totalCount = countTokens(node);
                    count.textContent = `${totalCount}`;
                    
                    header.appendChild(toggle);
                    header.appendChild(label);
                    header.appendChild(count);
                    
                    const childrenUl = document.createElement('ul');
                    childrenUl.className = 'tree-children';
                    li.setAttribute('data-path', pathStr);
                    
                    const childKeys = Object.keys(node).filter(k => k !== '_tokens' && !isHiddenTreeKey(k));
                    const sortOrder = tokenViewerConfig.treeSortOrder || [];
                    const typeStylesOrder = tokenViewerConfig.typeStylesSortOrder || [];
                    const useTypeStylesOrder = isInTextStylePreviewPath(nodePath) || pathStr.toLowerCase().includes('styles');
                    const activeOrder = useTypeStylesOrder && typeStylesOrder.length > 0 ? typeStylesOrder : sortOrder;
                    const sortedChildKeys = childKeys.sort((a, b) => {
                        const aLower = a.toLowerCase();
                        const bLower = b.toLowerCase();
                        const aIndex = activeOrder.indexOf(aLower);
                        const bIndex = activeOrder.indexOf(bLower);
                        if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                        if (aIndex !== -1) return -1;
                        if (bIndex !== -1) return 1;
                        return aLower.localeCompare(bLower);
                    });
                    
                    // Render child branches
                    sortedChildKeys.forEach(childKey => {
                        childrenUl.appendChild(renderTreeNode(childKey, node[childKey], depth + 1, nodePath));
                    });
                    
                    // Render leaf tokens
                    if (hasTokens) {
                        let tokensToRender = node._tokens;
                        const tokensArr = theme === 'dark' ? tokensDark : tokensLight;
                        // Text Style Preview: collapse typography properties (fontFamily, fontSize, etc.) into single composite card
                        if (isInTextStylePreviewPath(nodePath) && isTypographyGroup(tokensToRender)) {
                            tokensToRender = [synthesizeTypographyToken(tokensToRender, tokensArr)];
                        }
                        tokensToRender.forEach(token => {
                            const tokenLi = document.createElement('li');
                            tokenLi.className = 'tree-node';
                            
                            // Use theme-specific token for both preview and displayed value (so hex/values update with theme)
                            const tokenForPreview = getTokenByName(tokensArr, token.name) || token;
                            
                            // Check if we have metadata for this token
                            const metadata = tokenMetadata[token.name];
                            const originalValue = metadata?.original || token.value;
                            let resolvedValue = tokenForPreview.value;
                            
                            // Special handling for composite typography tokens - show styled sample instead of raw values
                            let typographyDisplay = null;
                            const typographyProps = tokenForPreview.typographyProps || getTypographyPropsFromSiblings(tokenForPreview, tokensArr);
                            if (typographyProps) {
                                typographyDisplay = getTypographyDisplay({ ...tokenForPreview, typographyProps });
                            }
                            
                            // Surface tokens: preview shows combined fill+effect; label uses consistent label style
                            const isSurfaceToken = token.isComposite && token.type === 'surface' && token.surfaceProps;
                            
                            // Check if this token references another token
                            const isReference = !isSurfaceToken && String(originalValue).includes('{') && String(originalValue).includes('}');
                            
                            // Build the card: 1) VISUAL PREVIEW (hero), 2) TOKEN NAME, 3) REFERENCE (if exists), 4) RESOLVED VALUE or styled sample
                            let infoHTML = '';
                            
                            if (typographyDisplay || isSurfaceToken) {
                                // For typography/surface: preview shows the style; label uses consistent label style (no inheritance)
                                // Include last segment (e.g. "subtle", "h1", "sm") for legibility within each category
                                const segments = token.name.replace(/^--/, '').split('-');
                                const lastSegment = segments.length ? segments[segments.length - 1] : '';
                                const friendlyLabel = lastSegment ? (lastSegment.match(/^h[1-6]$/i) ? lastSegment.toUpperCase() : lastSegment.charAt(0).toUpperCase() + lastSegment.slice(1)) : '';
                                infoHTML = `
                                    <div class="token-leaf-label-text">${token.name}${friendlyLabel ? ` <span class="token-leaf-category">· ${friendlyLabel}</span>` : ''}</div>
                                `;
                            } else if (isReference) {
                                // Show token name, then reference, then resolved value
                                infoHTML = `
                                    <div class="token-leaf-name">${token.name}</div>
                                    <div class="token-leaf-reference">${originalValue}</div>
                                    <div class="token-leaf-value">→ ${resolvedValue}</div>
                                `;
                            } else {
                                // Show token name, then value directly
                                infoHTML = `
                                    <div class="token-leaf-name">${token.name}</div>
                                    <div class="token-leaf-value">${resolvedValue}</div>
                                `;
                            }
                            const tokenCategory = getTokenCategory(token.name, token);
                            tokenLi.innerHTML = `
                                <div class="token-leaf" data-category="${tokenCategory}">
                                    ${renderPreview(tokenForPreview)}
                                    <div class="token-leaf-info">
                                        ${infoHTML}
                                    </div>
                                </div>
                            `;
                            childrenUl.appendChild(tokenLi);
                        });
                    }
                    
                    // Toggle expand/collapse
                    header.addEventListener('click', () => {
                        const isExpanded = childrenUl.classList.contains('expanded');
                        if (isExpanded) {
                            childrenUl.classList.remove('expanded');
                            toggle.classList.remove('expanded');
                        } else {
                            childrenUl.classList.add('expanded');
                            toggle.classList.add('expanded');
                        }
                    });
                    
                    li.appendChild(header);
                    li.appendChild(childrenUl);
                }
                
                return li;
            }
            
            // Count total tokens in a branch
            function countTokens(node) {
                let count = 0;
                if (node._tokens) count += node._tokens.length;
                Object.keys(node).forEach(key => {
                    if (key !== '_tokens') {
                        count += countTokens(node[key]);
                    }
                });
                return count;
            }
            
            const treeContainer = document.getElementById('token-tree');
            
            // Build and render the tree from current tokens (called on init and when alias/theme changes)
            function buildAndRenderTree() {
                const tree = buildTree(tokens);
                Object.keys(tree).forEach(key => {
                    collapseSingleChildFolders(tree[key]);
                });
                const sortOrder = tokenViewerConfig.treeSortOrder || [];
                const sortedKeys = Object.keys(tree).sort((a, b) => {
                    const aLower = a.toLowerCase();
                    const bLower = b.toLowerCase();
                    const aIndex = sortOrder.indexOf(aLower);
                    const bIndex = sortOrder.indexOf(bLower);
                    if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                    if (aIndex !== -1) return -1;
                    if (bIndex !== -1) return 1;
                    return aLower.localeCompare(bLower);
                });
                treeContainer.innerHTML = '';
                sortedKeys.filter(key => !isHiddenTreeKey(key)).forEach(key => {
                    treeContainer.appendChild(renderTreeNode(key, tree[key]));
                });
                document.getElementById('token-count').textContent = `${tokens.length} tokens`;
            }
            
            buildAndRenderTree();
            
            // Dynamic filter chips - built from actual token categories
            const filterChipsContainer = document.getElementById('filter-chips');
            const categories = new Set();
            tokens.forEach(t => categories.add(getTokenCategory(t.name, t)));
            const categoryList = tokens.length > 0
                ? Array.from(categories).filter(c => c !== 'other').sort((a, b) => {
                    const order = ['color', 'typography', 'gradient', 'surface', 'effect', 'opacity', 'spacing', 'sizing', 'font-weight', 'font-family', 'font-size', 'line-height', 'border-width', 'border-radius'];
                    const ai = order.indexOf(a);
                    const bi = order.indexOf(b);
                    if (ai !== -1 && bi !== -1) return ai - bi;
                    if (ai !== -1) return -1;
                    if (bi !== -1) return 1;
                    return a.localeCompare(b);
                })
                : (tokenViewerConfig.defaultFilterCategories || []);
            const displayNames = tokenViewerConfig.categoryDisplayNames || {};
            filterChipsContainer.innerHTML = '<button class="filter-chip active" data-category="all">All</button>' +
                categoryList.map(cat => {
                    const label = displayNames[cat] || cat.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    return `<button class="filter-chip" data-category="${cat}">${label}</button>`;
                }).join('');
            
            // Expand/Collapse All functionality
            document.getElementById('expand-all').addEventListener('click', () => {
                document.querySelectorAll('.tree-children').forEach(el => {
                    el.classList.add('expanded');
                });
                document.querySelectorAll('.tree-toggle').forEach(el => {
                    el.classList.add('expanded');
                });
            });
            
            document.getElementById('collapse-all').addEventListener('click', () => {
                document.querySelectorAll('.tree-children').forEach(el => {
                    el.classList.remove('expanded');
                });
                document.querySelectorAll('.tree-toggle').forEach(el => {
                    el.classList.remove('expanded');
                });
            });
            
            // Theme toggle
            const themeToggleBtn = document.getElementById('theme-toggle');
            function updateThemeToggleIcon() {
                themeToggleBtn.textContent = theme === 'dark' ? '☀️' : '🌙';
                themeToggleBtn.setAttribute('aria-label', theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode');
            }
            updateThemeToggleIcon();
            themeToggleBtn.addEventListener('click', () => {
                theme = theme === 'light' ? 'dark' : 'light';
                localStorage.setItem('tokenViewerTheme', theme);
                applyTheme();
                updateThemeToggleIcon();
                if (reRenderTokenTree) reRenderTokenTree();
            });

            // App tab switching
            let activeAlias = localStorage.getItem('tokenViewerAlias') || 'myQ';
            const appTabs = document.querySelectorAll('.app-tab');
            const appPanels = document.querySelectorAll('.app-panel');
            appTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const panelId = tab.dataset.panel;
                    appTabs.forEach(t => {
                        t.classList.remove('active');
                        t.setAttribute('aria-selected', 'false');
                    });
                    appPanels.forEach(p => {
                        p.classList.remove('active');
                    });
                    tab.classList.add('active');
                    tab.setAttribute('aria-selected', 'true');
                    document.getElementById(`panel-${panelId}`).classList.add('active');
                });
            });

            // Alias theme dropdown — switch tokens per theme
            const aliasSelect = document.getElementById('alias-select');
            aliasSelect.value = activeAlias;
            aliasSelect.addEventListener('change', () => {
                const value = aliasSelect.value;
                activeAlias = value;
                localStorage.setItem('tokenViewerAlias', value);
                const slug = aliasToSlug(value);
                const aliasData = tokensByAlias[slug];
                if (aliasData) {
                    tokensLight.length = 0;
                    tokensLight.push(...aliasData.light);
                    tokensDark.length = 0;
                    tokensDark.push(...aliasData.dark);
                    tokens = tokensLight;
                    Object.keys(tokenMetadata).forEach(k => delete tokenMetadata[k]);
                    Object.assign(tokenMetadata, aliasData.metadata);
                    document.documentElement.setAttribute('data-alias', slug);
                    if (reRenderTokenTree) reRenderTokenTree();
                } else {
                    console.warn(`Alias "${value}" not loaded.`);
                }
            });
            
            // Filter chip functionality
            let activeCategory = 'all';
            const filterChips = document.querySelectorAll('.filter-chip');
            
            filterChips.forEach(chip => {
                chip.addEventListener('click', () => {
                    // Update active state
                    filterChips.forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    
                    // Get selected category
                    activeCategory = chip.dataset.category;
                    
                    // Apply filter
                    applyFilters();
                });
            });
            
            // Search functionality
            const searchInput = document.getElementById('search');
            const searchClear = document.getElementById('search-clear');
            
            searchInput.addEventListener('input', () => {
                // Show/hide clear button based on input
                if (searchInput.value) {
                    searchClear.classList.add('visible');
                } else {
                    searchClear.classList.remove('visible');
                }
                applyFilters();
            });
            
            searchClear.addEventListener('click', () => {
                searchInput.value = '';
                searchClear.classList.remove('visible');
                applyFilters();
                searchInput.focus();
            });
            
            // Combined filter function
            function applyFilters() {
                const searchTerm = searchInput.value.toLowerCase();
                const leaves = document.querySelectorAll('.token-leaf');
                
                // First pass: Show/hide token leaves based on filters
                leaves.forEach(leaf => {
                    const nameEl = leaf.querySelector('.token-leaf-name') || leaf.querySelector('.token-leaf-label-text');
                    const name = nameEl ? nameEl.textContent.toLowerCase() : '';
                    const category = leaf.dataset?.category || getTokenCategory(name);
                    
                    const matchesSearch = name.includes(searchTerm) || searchTerm === '';
                    const matchesCategory = activeCategory === 'all' || category === activeCategory;
                    
                    leaf.parentElement.style.display = matchesSearch && matchesCategory ? 'block' : 'none';
                });
                
                // Second pass: Show/hide tree branches based on visible children
                // Process from bottom up to ensure parent visibility is correct
                const allTreeNodes = Array.from(document.querySelectorAll('.tree-node')).reverse();
                
                allTreeNodes.forEach(node => {
                    const childrenContainer = node.querySelector(':scope > .tree-children');
                    
                    if (childrenContainer) {
                        // Check if this branch has any visible descendants
                        const hasVisibleDescendants = Array.from(childrenContainer.querySelectorAll('.token-leaf')).some(
                            leaf => leaf.parentElement.style.display !== 'none'
                        ) || Array.from(childrenContainer.querySelectorAll(':scope > .tree-node')).some(
                            childNode => childNode.style.display !== 'none'
                        );
                        
                        if (hasVisibleDescendants) {
                            node.style.display = 'block';
                            // Auto-expand when filtering by category or search
                            if (activeCategory !== 'all' || searchTerm) {
                                childrenContainer.classList.add('expanded');
                            }
                        } else {
                            node.style.display = 'none';
                        }
                    } else {
                        // Leaf node (contains token-leaf), already handled in first pass
                    }
                });
                
                // If no filters active, show everything and collapse all
                if (!searchTerm && activeCategory === 'all') {
                    document.querySelectorAll('.tree-node').forEach(node => {
                        node.style.display = 'block';
                    });
                    document.querySelectorAll('.tree-children').forEach(container => {
                        container.classList.remove('expanded');
                    });
                    document.querySelectorAll('.tree-toggle').forEach(el => {
                        el.classList.remove('expanded');
                    });
                } else if (activeCategory !== 'all') {
                    // When filtering by category, expand all to show results
                    document.querySelectorAll('.tree-children').forEach(container => {
                        container.classList.add('expanded');
                    });
                    document.querySelectorAll('.tree-toggle').forEach(el => {
                        el.classList.add('expanded');
                    });
                }
            }
            
            // Capture expanded tree paths before re-render (for theme/alias toggle)
            function getExpandedPaths() {
                const paths = new Set();
                document.querySelectorAll('.tree-children.expanded').forEach(childrenEl => {
                    const node = childrenEl.closest('.tree-node');
                    if (node && node.dataset.path) paths.add(node.dataset.path);
                });
                return paths;
            }
            function restoreExpandedPaths(paths) {
                if (!paths || paths.size === 0) return;
                paths.forEach(pathStr => {
                    const node = document.querySelector(`.tree-node[data-path="${pathStr}"]`);
                    if (node) {
                        const children = node.querySelector(':scope > .tree-children');
                        const toggle = node.querySelector(':scope > .tree-header .tree-toggle');
                        if (children) children.classList.add('expanded');
                        if (toggle) toggle.classList.add('expanded');
                    }
                });
            }

            // Expose re-render for theme/alias toggle (rebuilds tree from current tokens)
            reRenderTokenTree = function() {
                const expandedPaths = getExpandedPaths();
                buildAndRenderTree();
                applyFilters();
                restoreExpandedPaths(expandedPaths);
            };
        }
    </script>
</body>
</html>
